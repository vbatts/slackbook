<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The Slack Book</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="The Slack Book"><div class="titlepage"><div><div><h1 class="title"><a name="id54440"></a>The Slack Book</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#id335177">Foreward</a></span></dt><dd><dl><dt><span class="section"><a href="#id337010">Intended Audience</a></span></dt><dt><span class="section"><a href="#id316534">Why A New Slackware Book?</a></span></dt><dt><span class="section"><a href="#id330458">Conventions Used in this Book</a></span></dt><dt><span class="section"><a href="#id335728">Acknowledgements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id317008">1. Introduction to Slackware</a></span></dt><dd><dl><dt><span class="section"><a href="#id311524">Why Use Slackware?</a></span></dt><dt><span class="section"><a href="#id311677">Differences with other Linux Distributions</a></span></dt><dt><span class="section"><a href="#id341400">Licensing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id297229">2. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#id352319">Booting the Installer</a></span></dt><dt><span class="section"><a href="#id330240">Partitioning</a></span></dt><dt><span class="section"><a href="#id326672">The <span class="application">setup</span> Program</a></span></dt><dd><dl><dt><span class="section"><a href="#id326687">Help</a></span></dt><dt><span class="section"><a href="#id326694">Keymap</a></span></dt><dt><span class="section"><a href="#id326702">Addswap</a></span></dt><dt><span class="section"><a href="#id326709">Target</a></span></dt><dt><span class="section"><a href="#id326717">Source</a></span></dt><dt><span class="section"><a href="#id326724">Select</a></span></dt><dt><span class="section"><a href="#id326732">Install</a></span></dt><dt><span class="section"><a href="#id326739">Configure</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id297222">3. Booting</a></span></dt><dd><dl><dt><span class="section"><a href="#id357891"><span class="application">mkinitrd</span></a></span></dt><dt><span class="section"><a href="#id326605">LILO</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id288954">4. Basic Shell Commands</a></span></dt><dd><dl><dt><span class="section"><a href="#id326497">System Documentation</a></span></dt><dt><span class="section"><a href="#id330395">Dealing with Files and Directories</a></span></dt><dd><dl><dt><span class="section"><a href="#id330401"><span class="application">Listing Files and Directory Contents</span></a></span></dt><dt><span class="section"><a href="#id351195">Moving Around the Filesystem</a></span></dt><dt><span class="section"><a href="#id354028">File and Directory Creation and Deletion</a></span></dt></dl></dd><dt><span class="section"><a href="#id354344">Reading Documents</a></span></dt><dt><span class="section"><a href="#id354528">Linking</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id336592">5. The Bourne Again Shell</a></span></dt><dd><dl><dt><span class="section"><a href="#id282479">What Is A Shell?</a></span></dt><dt><span class="section"><a href="#id314358">Environment Variables</a></span></dt><dt><span class="section"><a href="#id313824">Wildcards</a></span></dt><dt><span class="section"><a href="#id335881">Tab Completion</a></span></dt><dt><span class="section"><a href="#id354670">Input and Output Redirection</a></span></dt><dt><span class="section"><a href="#id354937">Terminals</a></span></dt><dt><span class="section"><a href="#id355019">Customization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id325945">6. The X Window System</a></span></dt><dd><dl><dt><span class="section"><a href="#id358884">What Is (And Isn't) X</a></span></dt><dt><span class="section"><a href="#id320754">Configuring the X Server</a></span></dt><dt><span class="section"><a href="#id314642">Choosing a Window Manager</a></span></dt><dt><span class="section"><a href="#id351028">Setting Up A Graphical Login</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id292994">7. Printing</a></span></dt><dd><dl><dt><span class="section"><a href="#id337782">Choosing A Printer</a></span></dt><dt><span class="section"><a href="#id357050">Setting Up a Printer in CUPS</a></span></dt><dt><span class="section"><a href="#id322037">Commandline Printing Tools</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id337784">8. Users and Groups</a></span></dt><dd><dl><dt><span class="section"><a href="#id359209">What Are Users and Groups?</a></span></dt><dt><span class="section"><a href="#id341153">Managing Users and Groups</a></span></dt><dt><span class="section"><a href="#id359270">Other User and Group Tools</a></span></dt><dt><span class="section"><a href="#id321249">Managing Users and Groups Manually</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id290832">9. Filesystem Permissions</a></span></dt><dd><dl><dt><span class="section"><a href="#id312644">Permissions Overview</a></span></dt><dt><span class="section"><a href="#id336783"><span class="application">chmod</span>,
<span class="application">chown</span>, and
<span class="application">chgrp</span></a></span></dt><dt><span class="section"><a href="#id342316">SUID, SGID, and the "Sticky" Bit</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id283108">10. Working with Filesystems</a></span></dt><dd><dl><dt><span class="section"><a href="#id325517">The Filesystem Hierarchy</a></span></dt><dt><span class="section"><a href="#id318597">Local Filesystem Types</a></span></dt><dd><dl><dt><span class="section"><a href="#id318610">ext2</a></span></dt><dt><span class="section"><a href="#id318624">ext3</a></span></dt><dt><span class="section"><a href="#id318642">reiserfs</a></span></dt><dt><span class="section"><a href="#id318656">XFS</a></span></dt><dt><span class="section"><a href="#id318671">JFS</a></span></dt><dt><span class="section"><a href="#id318685">iso9660</a></span></dt><dt><span class="section"><a href="#id318711">vfat</a></span></dt><dt><span class="section"><a href="#id355976">swap</a></span></dt></dl></dd><dt><span class="section"><a href="#id355992">Using <span class="application">mount</span></a></span></dt><dt><span class="section"><a href="#id360747">Network Filesystems</a></span></dt><dd><dl><dt><span class="section"><a href="#id360758">NFS</a></span></dt><dt><span class="section"><a href="#id360899">SMB</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id282063">11. <span class="application">vi</span></a></span></dt><dd><dl><dt><span class="section"><a href="#id352102">What is <span class="application">vi</span>?</a></span></dt><dt><span class="section"><a href="#id314220">The Different Modes of <span class="application">vi</span></a></span></dt><dt><span class="section"><a href="#id317601">Opening, Saving, and Quitting</a></span></dt><dt><span class="section"><a href="#id320876">Moving Around</a></span></dt><dt><span class="section"><a href="#id342976">Editing A Document</a></span></dt><dt><span class="section"><a href="#id343009"><span class="application">vi</span> Cheat Sheet</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id342041">12. Emacs</a></span></dt><dd><dl><dt><span class="section"><a href="#id317667">No Idea</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id289613">13. Networking</a></span></dt><dd><dl><dt><span class="section"><a href="#id328201"><span class="application">netconfig</span></a></span></dt><dt><span class="section"><a href="#id310624">Manual Configuration</a></span></dt><dt><span class="section"><a href="#id319849">Automatic Configuration with rc.inet1.conf</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id329344">14. Wireless Networking</a></span></dt><dd><dl><dt><span class="section"><a href="#id326142"><span class="application">iwconfig</span></a></span></dt><dt><span class="section"><a href="#id359178">Wired Equivilant Protection (or Lack Thereof)</a></span></dt><dt><span class="section"><a href="#id334833">WPA</a></span></dt><dt><span class="section"><a href="#id334290">rc.inet1.conf revisited</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id284408">15. Basic Networking Commands</a></span></dt><dd><dl><dt><span class="section"><a href="#id348624">Network Diagnostic Tools</a></span></dt><dt><span class="section"><a href="#id333340">Web Browsers</a></span></dt><dt><span class="section"><a href="#id351638">FTP Clients</a></span></dt><dt><span class="section"><a href="#id317884">NNTP Clients</a></span></dt><dt><span class="section"><a href="#id341101">Remote Access</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id320396">16. Package Management</a></span></dt><dd><dl><dt><span class="section"><a href="#id358328"><span class="application">pkgtool</span></a></span></dt><dt><span class="section"><a href="#id352958">Installing, Removing, and Upgrading Packages</a></span></dt><dt><span class="section"><a href="#id341343"><span class="application">pkgtool</span></a></span></dt></dl></dd><dt><span class="chapter"><a href="#id292742">17. Keeping Track of Updates</a></span></dt><dd><dl><dt><span class="section"><a href="#id314047">The -stable Branch</a></span></dt><dt><span class="section"><a href="#id324804">Upgrading Slackware Versions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id328461">18. The Linux Kernel</a></span></dt><dd><dl><dt><span class="section"><a href="#id322300">What Does the Kernel Do?</a></span></dt><dt><span class="section"><a href="#id325022">Working with Modules</a></span></dt><dt><span class="section"><a href="#id353213">Compiling A Kernel and Why to do So</a></span></dt></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>4.1. <a href="#id333534">Man Page Sections</a></dt><dt>9.1. <a href="#id337693">Permissions of /bin/ls</a></dt><dt>9.2. <a href="#id330724">Octal Permissions</a></dt><dt>9.3. <a href="#id342090">Alphabetic Permissions</a></dt><dt>9.4. <a href="#id342158">Alphabetic Users and Groups</a></dt><dt>9.5. <a href="#id342457">SUID, SGID, and "Sticky" Permissions</a></dt><dt>10.1. <a href="#id336627">Filesystem Layout</a></dt><dt>10.2. <a href="#id356105">Common mount options</a></dt><dt>11.1. <a href="#id348996">vi cursor movement</a></dt><dt>11.2. <a href="#id343030">vi Cheat Sheet</a></dt></dl></div><div class="preface" title="Foreward"><div class="titlepage"><div><div><h2 class="title"><a name="id335177"></a>Foreward</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id337010">Intended Audience</a></span></dt><dt><span class="section"><a href="#id316534">Why A New Slackware Book?</a></span></dt><dt><span class="section"><a href="#id330458">Conventions Used in this Book</a></span></dt><dt><span class="section"><a href="#id335728">Acknowledgements</a></span></dt></dl></div><div class="section" title="Intended Audience"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id337010"></a>Intended Audience</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Why A New Slackware Book?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id316534"></a>Why A New Slackware Book?</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Conventions Used in this Book"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id330458"></a>Conventions Used in this Book</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Acknowledgements"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id335728"></a>Acknowledgements</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div></div><div class="chapter" title="Chapter 1. Introduction to Slackware"><div class="titlepage"><div><div><h2 class="title"><a name="id317008"></a>Chapter 1. Introduction to Slackware</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id311524">Why Use Slackware?</a></span></dt><dt><span class="section"><a href="#id311677">Differences with other Linux Distributions</a></span></dt><dt><span class="section"><a href="#id341400">Licensing</a></span></dt></dl></div><div class="section" title="Why Use Slackware?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id311524"></a>Why Use Slackware?</h2></div></div></div><p>
Slackware has a long tradition of excellence.  Started in 1992 and
first released in 1993, Slackware is the oldest surviving commercial
Linux distribution.  Slackware's focus on making a clean, simple Linux
distribution that is as UNIX-like as possible makes it a natural choice
for those people who really want to learn about Linux and other
UNIX-like operating systems.  Slackware's simplicity makes it ideal for
those users who want to create their own custom systems.  And of course,
Slackware is great in its own right as a desktop, workstation, or server.
</p></div><div class="section" title="Differences with other Linux Distributions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id311677"></a>Differences with other Linux Distributions</h2></div></div></div><p>
There are a great number of differences between Slackware and other
main-stream distributions such as Red Hat, Debian, and Ubuntu.  Perhaps
the greatest difference is the lack of "hand-holding" that Slackware
will do for the administrator.  Many of these other distributions ship
with graphical configuration tools for all manner of services.  In many
cases these configuration tools are the preferred method of setting up
applications on these systems and will over-write any changes you make
to the config files via other means.  These tools often make it easy
(or at least possible) for a rookie with no in-depth understanding of
his system to setup basic services; however, they also make it
difficult to do anything too out of the ordinary.  In contrast,
Slackware expects you, the system administrator, to do these tasks on
your own.  Slackware provides no general purpose setup tools beyond
those included with the source code published by up-stream developers.
This means there is often a somewhat steeper learning curve associated
with Slackware, even for those users familiar with other Linux
distributions, but also makes it much easier to do whatever you want
with your operating system.
</p><p>
Also, you may hear users of other distributions say that Slackware has
no package management system.  This is completely and obviously false.
Slackware has always had package management (see Chapter 16 for more
information).  What it does not have is automatic dependency
resolution.  Rather, Slackware's package tools trade dependency
management for simplicity, ease-of-use, and reliability.
</p></div><div class="section" title="Licensing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id341400"></a>Licensing</h2></div></div></div><p>
Each piece of Slackware (indeed of all Linux distributions) is
developed by different people or teams of people, and each group has
their own ideas about what it means to be "free".  Because of this
there are literally dozens and dozens of different licenses granting
you different permissions regarding their use or distribution.
</p><p>
Perhaps the most popular license in use within the Free Software
community is the GNU General Public License.  
The GPL was created by the Free Software
Foundation which actively works to create and distribute software that
contains the basic freedoms they fill are basic rights.  Indeed, this
is the very group that coined the term "Free Software".  The GPL
imposes no restrictions on the use of software.  In fact, you don't
even have to accept the terms of the license in order to use the
software, but you are not allowed to distribute the software or your
changes to it without abiding by the terms of the license agreement.  A
great many software projects shipped with Slackware from the Linux
kernel itself to the Samba project are released under the terms of the
GPL.
</p><p>
Another very common license is the BSD license, which is arguably "more
free" than the GPL, but imposes no restrictions on derivative works.
The BSD license simply requires that the copyright remain intact, along
with a simple disclaimer.  Many of the utilities specific to Slackware
are licensed with a BSD-style license.
</p></div></div><div class="chapter" title="Chapter 2. Installation"><div class="titlepage"><div><div><h2 class="title"><a name="id297229"></a>Chapter 2. Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id352319">Booting the Installer</a></span></dt><dt><span class="section"><a href="#id330240">Partitioning</a></span></dt><dt><span class="section"><a href="#id326672">The <span class="application">setup</span> Program</a></span></dt><dd><dl><dt><span class="section"><a href="#id326687">Help</a></span></dt><dt><span class="section"><a href="#id326694">Keymap</a></span></dt><dt><span class="section"><a href="#id326702">Addswap</a></span></dt><dt><span class="section"><a href="#id326709">Target</a></span></dt><dt><span class="section"><a href="#id326717">Source</a></span></dt><dt><span class="section"><a href="#id326724">Select</a></span></dt><dt><span class="section"><a href="#id326732">Install</a></span></dt><dt><span class="section"><a href="#id326739">Configure</a></span></dt></dl></dd></dl></div><p>
Slackware's installation is a bit more simplistic than many other Linux
distributions use, and is very reminiscent of installing one of the
varieties of BSD operating systems.  If you're familiar with those, you
should feel right at home.  If you've never installed Slackware or used
a distribution that makes use of a non-graphical installer, you may
feel a bit overwhelmed.  Don't panic.  The installation is very easy
once you understand it, and works on just about any x86 platform.
</p><p>
The latest versions of Slackware Linux are distributed on DVD or CD
media, but Slackware can be installed in a variety of other ways.  This
book will only focus on the most common way: installing via optical
media.  In order to install Slackware, you'll need at least an Intel
486 or equivilant CPU, but we recommend you obtain a 586 or better CPU
if at all possible.  Slackware can be pared down to run on as little as
32 MB of RAM (or even less), but with the size of the 2.6 kernel and
user-space applications, you will find yourself having a much easier
time if you have a minimum of 64 MB of RAM.  If you wish to use
anything older than these, you might want to obtain an older copy of
Slackware which will perform better with fewer CPU Megahertz and less
RAM.
</p><div class="section" title="Booting the Installer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id352319"></a>Booting the Installer</h2></div></div></div><p>
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
</p></div><div class="section" title="Partitioning"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id330240"></a>Partitioning</h2></div></div></div><p>
Unlike many other Linux distributions, Slackware does not make use of a
graphical disk partitioning tool in its installer.  Rather, Slackware
makes use of <span class="application">fdisk</span>(8) and
<span class="application">cfdisk</span>(8), both console tools.
<span class="application">cfdisk</span> is a curses-based partitioning tool
while <span class="application">fdisk</span> is not.  Whichever you choose to
use should only rarely matter.  In this book, we'll only discuss
<span class="application">fdisk</span>.
</p><p>
In order to partition your hard drive, you'll first need to know how to
identify it.  In Linux, all hardware is identified by a special file
called a device file.  These are all (typically) located in the
<code class="filename">/dev</code> directory.  If your hard drive is IDE, you
will most likely find it as <code class="filename">/dev/hda</code>; however,
many hard drives today including SATA disks are identified as SCSI
devices by the kernel.  If you don't know what your hard drive is
identified in Linux as, <span class="application">fdisk</span> can help you
out.
</p><pre class="screen"><code class="prompt">root@slackware:/# </code><strong class="userinput"><code>fdisk -l</code></strong>

Disk /dev/sda: 72.7 GB, 72725037056 bytes
255 heads, 63 sectors/track, 8841 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
</pre><p>
Here, you can see that my system has a hard drive located at
<code class="filename">/dev/sda</code> that is 72.7 GB in size.  You can also
see some additional info about this hard drive.  (In my case, this is
actually three SCSI hard drives on a hardware RAID controller that
makes them appear as a single drive.)  The  [-l] argument to
<span class="application">fdisk</span> tells it to display the hard drives
and all the partitions it finds on those drives, but won't make any
changes to the disks.  In order to actually partition our drives, we'll
have to tell <span class="application">fdisk</span> what drive to operate on.
</p><pre class="screen"><code class="prompt">root@slackware:/# </code><strong class="userinput"><code>fdisk /dev/sda</code></strong>

The number of cylinders for this disk is set to 8841.
There is nothing wrong with that, but this is larger than 1024,
and could in certain setups cause problems with:
1) software that runs at boot time (e.g., old versions of LILO)
2) booting and partitioning software from other OSs
   (e.g., DOS FDISK, OS/2 FDISK)

Command (m for help):
</pre><p>
Now we've told fdisk what disk we wish to partition and it has dropped
us into command mode after printing an annoying warning message.  The
1024 cylinder limit has not been a problem for some time, and
Slackware's boot loader will have no trouble booting disks larger than
this.  Typing [m] and hitting ENTER will print out a helpful
message telling you what to do with <span class="application">fdisk</span>.
</p><pre class="screen">Command (m for help): <strong class="userinput"><code>m</code></strong>

FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!
FILL THIS IN!  FILL THIS IN!

</pre><p>
Now that we know what commands will do what, it's time to begin to
partition our drive.  At a minimum, you will need a single
<code class="filename">/</code> partition and should create a swap partition.
You might also want to make a seperate <code class="filename">/home</code>
partition for storing user files (this will make it easier to upgrade
later, or install a different Linux operating system by keeping all of
your users' files on a seperate partition).  So, let's go ahead and
make three partitions.  The command to create a new partition is
 [n] (which you would have noticed if you read the help).
</p><pre class="screen">Command: (me for help): <strong class="userinput"><code>n</code></strong>
Command action
   e   extended
   p   primary partition (1-4)
<strong class="userinput"><code>p</code></strong>
Partition number (1-4): <strong class="userinput"><code>1</code></strong>
First cylinder (1-8841, default 1): <strong class="userinput"><code>1</code></strong>
Last cylinder or +size or +sizeM or +sizeK (1-8841, default 8841): <strong class="userinput"><code>+8G</code></strong>

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
<strong class="userinput"><code>p</code></strong>
Partition number (1-4): <strong class="userinput"><code>2</code></strong>
First cylinder (975-8841, default 975): <strong class="userinput"><code>975</code></strong>
Last cylinder or +size or +sizeM or +sizeK (975-8841, default 8841): <strong class="userinput"><code>+1G</code></strong>
</pre><p>
Here we have created two partitions.  The first is 8GB in size and the
second is only 1GB.  We can view our existing partitions with the
[p] command.
</p><pre class="screen"> Command (m for help): <strong class="userinput"><code>p</code></strong>

Disk /dev/sda: 72.7 GB, 72725037056 bytes
255 heads, 63 sectors/track, 8841 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot       Start      End          Blocks   Id  System
/dev/sda1                1      974         7823623+  83  Linux
/dev/sda2              975     1097          987997+  83  Linux

</pre><p>
Both of these partitions are of type "83" which is the standard Linux
filesystem.  We will need to change <code class="filename">/dev/sda2</code> to
type "82" in order to make this a swap partition.  We will do this with
the  [t] command.
</p><pre class="screen">Command (m for help): <strong class="userinput"><code>t</code></strong>
Partition number (1-4): <strong class="userinput"><code>2</code></strong>
Hex code (type L to list codes): <strong class="userinput"><code>82</code></strong>

Command (me for help): <strong class="userinput"><code>p</code></strong>

Disk /dev/sda: 72.7 GB, 72725037056 bytes
255 heads, 63 sectors/track, 8841 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot       Start      End          Blocks   Id  System
/dev/sda1                1      974         7823623+  83  Linux
/dev/sda2              975     1097          987997+  82  Linux swap

</pre><p>The swap partition is a special partition that is used for
virtual memory by the Linux kernel.  If for some reason you run out of
RAM, the kernel will move the contents of some of the RAM to swap in
order to prevent a crash.  The size of your swap partition is up to
you.  A great many people have participated have participated in a
great many flamewars on the size of swap partitions, but a good rule of
thumb is to make your swap partition about twice the size of your
system's RAM.  Since my machine has only 512MB of RAM, I decided to
make my swap partition 1GB.  You may wish to experiment with your swap
partition's size and see what works best for you, but generally there
is no harm in having "too much" swap.
</p><p>
At this point we can stop, write these changes to the disk, and
continue on, but I'm going to go ahead and make a third partition which
will be mounted at <code class="filename">/home</code>.
</p><pre class="screen">Command: (me for help): <strong class="userinput"><code>n</code></strong>
Command action
   e   extended
   p   primary partition (1-4)
<strong class="userinput"><code>p</code></strong>
Partition number (1-4): <strong class="userinput"><code>3</code></strong>
First cylinder (1098-8841, default 1098): <strong class="userinput"><code>1098</code></strong>
Last cylinder or +size or +sizeM or +sizeK (1098-8841, default 8841): <strong class="userinput"><code>8841</code></strong>
</pre><p>
Now it's time to finish up and write these changes to disk.
</p><pre class="screen">Command: (me for help): <strong class="userinput"><code>w</code></strong>
The partition table has been altered!

Calling ioctl() to re-read partition table.
Synching disks.
<code class="prompt">root@slackware:/# </code>
</pre><p>
At this point, we are through partitioning our disks and are ready to
begin the <span class="application">setup</span> program.  However, if you
have created any extended partitions, you may wish to reboot once to
ensure that they are properly read by the kernel.
</p></div><div class="section" title="The setup Program"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id326672"></a>The <span class="application">setup</span> Program</h2></div></div></div><div class="section" title="Help"><div class="titlepage"><div><div><h3 class="title"><a name="id326687"></a>Help</h3></div></div></div></div><div class="section" title="Keymap"><div class="titlepage"><div><div><h3 class="title"><a name="id326694"></a>Keymap</h3></div></div></div></div><div class="section" title="Addswap"><div class="titlepage"><div><div><h3 class="title"><a name="id326702"></a>Addswap</h3></div></div></div></div><div class="section" title="Target"><div class="titlepage"><div><div><h3 class="title"><a name="id326709"></a>Target</h3></div></div></div></div><div class="section" title="Source"><div class="titlepage"><div><div><h3 class="title"><a name="id326717"></a>Source</h3></div></div></div></div><div class="section" title="Select"><div class="titlepage"><div><div><h3 class="title"><a name="id326724"></a>Select</h3></div></div></div></div><div class="section" title="Install"><div class="titlepage"><div><div><h3 class="title"><a name="id326732"></a>Install</h3></div></div></div></div><div class="section" title="Configure"><div class="titlepage"><div><div><h3 class="title"><a name="id326739"></a>Configure</h3></div></div></div></div></div></div><div class="chapter" title="Chapter 3. Booting"><div class="titlepage"><div><div><h2 class="title"><a name="id297222"></a>Chapter 3. Booting</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id357891"><span class="application">mkinitrd</span></a></span></dt><dt><span class="section"><a href="#id326605">LILO</a></span></dt></dl></div><p>
Ok, now that you've gotten Slackware installed on your system, you
should learn exactly what controls the boot sequence of your machine,
and how to fix it should you manage to break it somehow. Use Linux long
enough, and sooner or later you will make a mistake that breaks your
bootloader. Fortunately, this doesn't require a re-install to fix. Unlike
many other operating systems that hide the underlying details of how they
work, Linux (and in particular, Slackware) gives you full control over
the boot process. Simply by editing a configuration file or two and
re-running the boot-loader installer, you can quickly and easily change
(or break) your system. Slackware even makes it easy to dual-boot
between multiple operating systems such as other Linux distributions or
Microsoft Windows.
</p><div class="section" title="mkinitrd"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id357891"></a><span class="application">mkinitrd</span></h2></div></div></div><p>
Before we go any further, a quick discussion on the Linux kernel is
warranted. Slackware Linux includes several different kernels. While
they are all compiled from the same source code, and hence are the
"same", they are not identical. Depending on your architecture and
Slackware version, the installer may have loaded your system with
several kernels. There are kernels for single-processor
systems and kernels for multi-processor systems. In the old days, there
were tons of kernels for installing on different kinds of hard drive
controllers. More importantly for our discussion, there are "huge"
kernels and "generic" kernels.
</p><p>
If you look inside your <code class="filename">/boot</code> directory, you'll
see the various kernels installed on your system.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /boot/vmlinuz*</code></strong>
/boot/vmlinuz-huge-2.6.29.4      /boot/vmlinuz-generic-2.6.29.4
</pre><p>
Here you can see that I have two kernels installed,
<code class="filename">vmlinuz-huge-2.6.29.4</code> and
<code class="filename">vmlinuz-generic-2.6.29.4</code>. Each Slackware release
includes different kernel versions and sometimes even slightly
different names, so don't be alarmed if what you see doesn't exactly
match what I have listed here.
</p><p>
Huge kernels are exactly what you might think; they're huge. These
kernels are built to support nearly every conceivable computer
Slackware is supported on. They most certainly contain support for
hardware your machine does not, and never will, have. These are
included for several reasons, but the most important perhaps is in use
by the installer. These are the kernels the Slackware installation
disks run. If you chose to let the installer configure your bootloader
for you, it chooses to use these kernels due to the incredible variety
of hardware they support. By contrast, the generic kernels support very
little hardware without the use of external modules. If you want to use
one of the generic kernels, you'll need to make use of something called
an initrd, and the tool to make them,
<span class="application">mkinitrd</span>(8).
</p><p>
So why should you use a generic kernel? Currently the Slackware
development team recommends use of a generic kernel for a variety of
reasons. Perhaps the most obvious is size. The huge kernels are
currently about twice the size of the generic kernels before they are
uncompressed and loaded into memory. If you are running an older
machine, or one with some small ammount of RAM, you will appreciate the
savings the generic kernels offer you. Other reasons are somewhat more
difficult to quantify. Conflicts between drivers included in the huge
kernels do appear from time-to-time, and generally speaking, the huge
kernels do not perform as well as the generic ones. Also, by using the
generic kernels, special arguments can be passed to hardware drivers
seperately, rather than requiring these options be passed on the kernel
command line. Some of the tools included with Slackware work better if
your kernel uses some drivers as modules rather than "hard-coding" them
into the kernel. If you're having trouble understanding this, don't be
alarmed, just think "huge kernel: good, generic kernel: better".
</p><p>
Unfortunately, using the generic kernels isn't as straight-forward as
using the huge kernels. In order for the generic kernel to boot your
system, you must also usually include a few basic modules in an
initird. Modules are pieces of compiled kernel code that can be
inserted or removed from a running kernel. This makes the system
somewhat more flexible at the cost of a tiny bit of added complexity.
You might find it easier to think of modules as device drivers, at
least for this section. Typically you will need to add the module for
whatever filesystem you chose to use for your root partition during the
installer. If your root partition is located on a SCSI disk or RAID
controller, you'll need to load those modules as well.  Finally, if
you're using software RAID, disk encryption, or LVM, you'll also need
to create an initrd whether you're using the generic kernel or not.
</p><p>
initrds are compressed <span class="application">cpio</span>(1) archives, so
creating them isn't very straightforward.  Fortunately for you,
Slackware includes a tool that makes this very easy,
<span class="application">mkinitrd</span>. A full discussion of
<span class="application">mkinitrd</span> is a bit beyond the scope of this
book, but we'll show you all the highlights. For a more complete
explanation, check the manpage or run
<span class="application">mkinitrd</span> with the  [--help]
argument.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mkinitrd --help</code></strong>
mkinitrd creates an initial ramdisk (actually an initramfs cpio+gzip
archive) used to load kernel modules that are needed to mount the
root filesystem, or other modules that might be needed before the
root filesystem is available.  Other binaries may be added to the
initrd, and the script is easy to modify.  Be creative.  :-)
.... many more lines deleted ....
</pre><p>
When using <span class="application">mkinitrd</span>, you'll need to know a
few items of information: your root partition, your root filesystem,
any hard disk controllers you're using, and whether or not you're using
LVM, software RAID, or disk encryption. Unless you're using some kind
of SCSI controller (and have your root partition loaded on the SCSI
controller), you should only need to know your root filesystem and
partition type. Assuming you've booted into your Slackware installation
using the huge kernel, you can easily find this information with the
<span class="application">mount</span> command.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount</code></strong>
/dev/sda1 on / type ext4 (rw,barrier=1,data=ordered)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
usbfs on /proc/bus/usb type usbfs (rw)
/dev/sda2 on /home type jfs (rw)
tmpfs on /dev/shm type tmpfs (rw)
</pre><p>
In the example provided, you can see that the root partition is located
on <code class="filename">/dev/sda1</code> and is an ext4 type partition. If we
want to create an initrd for this system, we simply need to tell this
information to <span class="application">mkinird</span>.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mkinitrd -f ext4 -r /dev/sda1</code></strong>
</pre><p>
Note that in most cases, <span class="application">mkinitrd</span> is smart
enough to determine this information on its own, but it never hurts to
specify it manually. Now that we've created out initrd, we simply need
to tell LILO where to find it. We'll focus on that in the next section.
</p><p>
Looking up all those different options for
<span class="application">mkinitrd</span> or worse, memorizing them, can be a
real pain though, especially if you try out different kernels
consistently. This became tedious for the Slackware development team,
so they came up with a simple configuration file,
<code class="filename">mkinitrd.conf</code>(5). You can find a sample file that
can be easily customized for your system under the
<code class="filename">/etc</code> directory. Here's mine.
</p><pre class="screen"># mkinitrd.conf.sample
# See "man mkinitrd.conf" for details on the syntax of this file
#
SOURCE_TREE="/boot/initrd-tree"
CLEAR_TREE="0"
OUTPUT_IMAGE="/boot/initrd.gz"
KERNEL_VERSION="$(uname -r)"
#KEYMAP="us"
MODULE_LIST="ext3:ext4:jfs"
#LUKSDEV="/dev/hda1"
ROOTDEV="/dev/raven/64root"
ROOTFS="ext4"
#RESUMEDEV="/dev/hda2"
#RAID="0"
LVM="1"
#WAIT="1"
</pre><p>
For a complete description of each of these lines and what they do,
you'll need to consulte the man page for
<code class="filename">mkinitrd.conf</code>. Once each of these is setup, you
need only run <span class="application">mkinitrd</span> with the
 [-F] argument. A proper initrd file will be constructed and
installed for you, without you having to remember all those obscure
arguments.
</p></div><div class="section" title="LILO"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id326605"></a>LILO</h2></div></div></div><p>
LILO is the Linux Loader, and currently the default boot loader
installed with Slackware Linux. If you've used other Linux
distributions before, you may be more familiar with GRUB. If you prefer
to use it, you can easily find it in the <code class="filename">extra/</code>
directory on one of your Slackware CDs. Since LILO is the default
Slackware bootloader however, we'll focus exclusively on it.
</p><p>
Configuring LILO can be a little daunting for new users, so Slackware
comes with a special setup tool, <span class="application">liloconfig</span>.
Normally, <span class="application">liloconfig</span> is first run by the
installer, but you can run it at anytime from a terminal.
</p><p>
FILL THIS IN!!!!  Picture of liloconfig
</p><p>
<span class="application">liloconfig</span> has two modes of operation:
simple and expert. The simple mode tries to automatically configure
lilo for you. If Slackware is the only operating system installed on
your computer, the simple mode will almost always do the right thing
quickly and easily. It is also very good at detecting Windows
installations and adding them to the <code class="filename">lilo.conf</code>
file so that you can choose which operating system to boot when you
turn your computer on.
</p><p>
In order to use expert mode, you'll need to know Slackware's root
partition. You can also setup other linux operating systems if you know
their root partitions, but this may not work as well as you'd expect.
<span class="application">liloconfig</span> will try to boot each linux
operating system with Slackware's kernel, and this is probably not what
you want. Fortunately, setting up Windows partitions in expert mode is
trivial. One hint when using expert mode. You should almost always
install LILO to the Master Boot Record (MBR). Once upon a time, it was
recommended to install the boot loader onto the root partition and set
that partition as bootable. Today, LILO has matured greatly and is safe
to install on the MBR. In fact, you will encounter fewer problems if
you do so.
</p><p>
<span class="application">liloconfig</span> is a great way to quickly setup
your boot loader, but if you really need to know what's going on you'll
need to look at LILO's configuration file,
<code class="filename">lilo.conf</code>(5) under the <code class="filename">/etc</code>
directory. The <code class="filename">lilo.conf</code> file is seperated into
several sections. At the top you'll find a global section where you
specify things like where to install LILO (generally the MBR), any
special images or screens to show on boot, and the timeout after which
LILO will boot the default operating system. Here's what the global
section of my lilo.conf file looks like in part.
</p><pre class="screen"># LILO configuration file

boot = /dev/sda
  bitmap = /boot/slack.bmp
  bmp-colors = 255,0,255,0,255,0
  bmp-table = 60,6,1,16
  bmp-timer = 65,27,0,255

append=" vt.default_utf8=0"
prompt
timeout = 50

# VESA framebuffer console @ 1024x768x256
vga = 773
.... many more lines ommitted ....
</pre><p>
For a complete listing of all the possible LILO options, you should
consult the man page for <code class="filename">lilo.conf</code>. In brief,
we'll discuss the most common in this document.
</p><p>
The first thing that should draw your attention is the boot line. This
determines where the bootloader is installed. In order to install the
the MBR of your hard drive, you simply list the hard drive's device
entry on this line. In my case, I'm using a SATA hard drive that shows
up as SCSI device <code class="filename">/dev/sda</code>. If you're using an IDE
drive, you will probably have to use <code class="filename">/dev/hda</code>. In
order to install to the boot block of a partition, you'll have to list
the partition's device entry. For example, if you are installing to the
first partition on the only SATA hard drive in your computer, you would
probably use <code class="filename">/dev/sda1</code>.
</p><p>
The prompt option simply tells LILO to ask (prompt) you for which
operating system to boot.  Operating systems are each listed in their
own section deeper in the file. We'll get to them in a minute. The
timeout option tells LILO how long to wait (in tenths of seconds)
before booting the default OS. In my case, this is 5 seconds. Some
systems seem to take a very long time to display the boot screen, so
you may need to use a larger timeout value than I have set. This is in
part why the simple LILO installation method utilizes a very long
timeout (somewhere around 2 whole minutes). The append line in my case
was setup by <span class="application">liloconfig</span>. You may (and
probably should) see something similar when looking at your own
<code class="filename">lilo.conf</code>. I won't go into the details of why this
line is needed, so you're just going to have to trust me that things
work better if it is present. :^)
</p><p>
Now that we've looked into the global section, let's take a look at the
operating systems section. Each linux operating system section begins
with an "image" line. Microsoft Windows operating systems are specified
with an "other" line. Let's take a look at a sample
<code class="filename">lilo.conf</code> that boots both Slackware and Microsoft
Windows.
</p><pre class="screen"># LILO configuration file
... global section ommitted ....
# Linux bootable partition config begins
image = /boot/vmlinuz-generic-2.6.29.4
  root = /dev/raven/64root
  initrd = /boot/initrd.gz
  label = Slackware64
  read-only
# Linux bootable partition config ends
# Windows bootable partition config begins
other = /dev/sda3
  label = Windows
  table = /dev/sda
# Windows bootable partition config ends
</pre><p>
For Linux operating systems like Slackware, the image line specifies
which kernel to boot. In this case, we're booting
<code class="filename">/boot/vmlinuz-generic-2.6.29.4</code>. The remaining
sections are pretty self-explainatory. The tell LILO where to find the
root filesystem, what initrd (if any) to use, and to initially mount
the root filesystem read-only. That initrd line is very important for
anyone running a generic kernel, or using LVM or software RAID. It
tells LILO (and the kernel) where to find the initrd you created using
<span class="application">mkinitrd</span>.
</p><p>
Once you've gotten your <code class="filename">lilo.conf</code> setup for your
machine, simply run <span class="application">lilo</span>(8) to install it.
Unlike GRUB and other bootloaders, LILO requires you re-run
<span class="application">lilo</span> anytime you make changes to its
configuration file in order for those changes to be installed.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>lilo</code></strong>
Warning: LBA32 addressing assumed
Warning: '/proc/partitions' does not match '/dev' directory structure.
    Name change: '/dev/dm-0' -&gt; '/dev/raven/swap'
Warning: Name change: '/dev/dm-1' -&gt; '/dev/raven/root'
Warning: Name change: '/dev/dm-2' -&gt; '/dev/raven/home'
Warning: Name change: '/dev/dm-3' -&gt; '/dev/raven/src'
Warning: Name change: '/dev/dm-4' -&gt; '/dev/raven/64root'
Added Slackware *
Added Backup
6 warnings were issued.
</pre><p>
Don't be scared by many of the warnings you may see when running
<span class="application">lilo</span>. In my case, most of these warnings are
issued by the use of LVM. Unless you see a fatal error, things should
be just fine.
</p></div></div><div class="chapter" title="Chapter 4. Basic Shell Commands"><div class="titlepage"><div><div><h2 class="title"><a name="id288954"></a>Chapter 4. Basic Shell Commands</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id326497">System Documentation</a></span></dt><dt><span class="section"><a href="#id330395">Dealing with Files and Directories</a></span></dt><dd><dl><dt><span class="section"><a href="#id330401"><span class="application">Listing Files and Directory Contents</span></a></span></dt><dt><span class="section"><a href="#id351195">Moving Around the Filesystem</a></span></dt><dt><span class="section"><a href="#id354028">File and Directory Creation and Deletion</a></span></dt></dl></dd><dt><span class="section"><a href="#id354344">Reading Documents</a></span></dt><dt><span class="section"><a href="#id354528">Linking</a></span></dt></dl></div><p>
So you've installed Slackware and you're staring at a terminal prompt,
what now?  Now would be a good time to learn about the basic command
line tools.  And since you're staring at a blinking curser, you
probably need a little assistance in knowing how to get around, and
that is what this chapter is all about.
</p><div class="section" title="System Documentation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id326497"></a>System Documentation</h2></div></div></div><p>
Your Slackware Linux system comes with lots of built-in documentation
for nearly every installed application.  Perhaps the most common method
of reading system documentation is by using the
<span class="application">man</span>(1).  <span class="application">man</span>
(short for manual) will bring up the included man-page for any
application, system call, configuration file, or library you tell it
too.  For example, <strong class="userinput"><code>man man</code></strong> will bring up the
man-page for <span class="application">man</span> itself.
</p><p>
Unfortunately, you may not always know what application you need to use
for the task at hand.  Thankfully, <span class="application">man</span> has
built-in search abilities.  Using the  [-k] switch
will cause <span class="application">man</span> to search for every man-page
that matches your search terms.
</p><p>
The man-pages are organized into groups or sections by their content
type.  For example, section 1 is for user applications.
<span class="application">man</span> will search each section in order and
display the first match it finds.  Sometimes you will find that a
man-page exists in more than one section for a given entry.  In that
case, you will need to specify the exact section to look in.  In this
book, all applications and a number of other things will have a number
on their right-hand side in parenthesis.  This number is the man page
section where you will find information on that tool.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>man -k printf</code></strong>
printf               (1)  - format and print data
printf               (3)  - formatted output conversion
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>man 3 printf</code></strong>
</pre><div class="table"><a name="id333534"></a><p class="title"><b>Table 4.1. Man Page Sections</b></p><div class="table-contents"><table summary="Man Page Sections" border="0"><colgroup><col><col></colgroup><thead><tr><th>Section</th><th align="right">Contents</th></tr></thead><tbody><tr><td>1</td><td align="right">User Commands</td></tr><tr><td>2</td><td align="right">System Calls</td></tr><tr><td>3</td><td align="right">C Library Calls</td></tr><tr><td>4</td><td align="right">Devices</td></tr><tr><td>5</td><td align="right">File Formats / Protocols</td></tr><tr><td>6</td><td align="right">Games</td></tr><tr><td>7</td><td align="right">Conventions / Macro Packages</td></tr><tr><td>8</td><td align="right">System Administration</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Dealing with Files and Directories"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id330395"></a>Dealing with Files and Directories</h2></div></div></div><div class="section" title="Listing Files and Directory Contents"><div class="titlepage"><div><div><h3 class="title"><a name="id330401"></a><span class="application">Listing Files and Directory Contents</span></h3></div></div></div><p>
<span class="application">ls</span>(1) is used to list files and directories,
their permissions, size, type, inode number, owner and group, and
plenty of additional information.  For example, let's list what's in
the <code class="filename">/</code> directory for your new Slackware Linux system.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls /</code></strong>
bin/   dev/  home/  lost+found/  mnt/  proc/  sbin/  sys/  usr/
boot/  etc/  lib/   media/       opt/  root/  srv/   tmp/  var/
</pre><p>Notice that each of the listings is a directory.  These are
easily distinguished from regular files due to the trailing /; standard
files do not have a suffix.  Additionally, executable files will have an
asterisk suffix.  But <span class="application">ls</span> can do so much
more.  To get a view of the permissions of a file or directory, you'll
need to do a "long list".
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls -l /home/alan/Desktop</code></strong>
-rw-r--r-- 1 alan users 15624161 2007-09-21 13:02 9780596510480.pdf
-rw-r--r-- 1 alan users  3829534 2007-09-14 12:56 imgscan.zip
drwxr-xr-x 3 alan root       168 2007-09-17 21:01 ipod_hack/
drwxr-xr-x 2 alan users      200 2007-12-03 22:11 libgpod/
drwxr-xr-x 2 alan users      136 2007-09-30 03:16 playground/
</pre><p>
A long listing lets you view the permisions, user and group ownership,
file size, last modified date, and of course, the file name itself.
Notice that the first two entires are files, and the last three are
directories.  This is denoted by the very first character on the line.
Regular files get a "-"; directories get a "d".  There are several
other file types with their own denominators.  Symbolic links for
example will have an "l".
</p><p>
Lastly, we'll show you how to list dot-files, or hidden files.  Unlike
other operating systems such as Microsoft Windows, there is no special
property that differentiates "hidden" files from "unhidden" files.  A
hidden file simply begins with a dot.  To display these files along
with all the others, you just need to pass the [-a] argument to
<span class="application">ls</span>.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls -a</code></strong>
.xine/    .xinitrc-backup  .xscreensaver  .xsession-errors  SBo/
.xinitrc  .xinitrc-xfce    .xsession      .xwmconfig/       Shared/
</pre><p>
You also likely noticed that your files and directories appear in
different colors.  Many of the enhanced features of
<span class="application">ls</span> such as these colors or the trailing
characters indicating file-type are special features of the
<span class="application">ls</span> program that are turned on by passing
various arguments.  As a convienience, Slackware sets up
<span class="application">ls</span> to use many of these optional arguments
by default.  These are controlled by the LS_OPTIONS and LS_COLORS
environment variables.  We will talk more about environment variables
in chapter 5.
</p></div><div class="section" title="Moving Around the Filesystem"><div class="titlepage"><div><div><h3 class="title"><a name="id351195"></a>Moving Around the Filesystem</h3></div></div></div><p>
<span class="application">cd</span> is the command used to change
directories.  Unlike most other commands, <span class="application">cd</span>
is actually not it's own program, but is a shell built-in.  Basically,
that means <span class="application">cd</span> does not have its own man
page.  You'll have to check your shell's documentation for more details
on the <span class="application">cd</span> you may be using.  For the most
part though, they all behave the same.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cd /</code></strong>
<code class="prompt">darkstar:/$</code><strong class="userinput"><code>ls</code></strong>
bin/   dev/  home/  lost+found/  mnt/  proc/  sbin/  sys/  usr/
boot/  etc/  lib/   media/       opt/  root/  srv/   tmp/  var/
<code class="prompt">darkstar:/$</code><strong class="userinput"><code>cd /usr/local</code></strong>
<code class="prompt">darkstar:/usr/local$</code>
</pre><p>
Notice how the prompt changed when we changed directories?  The default
Slackware shell does this as a quick, easy way to see your current
directory, but this is not actually a function of
<span class="application">cd</span>.  If your shell doesn't operate in this
way, you can easily get your current working directory with the
<span class="application">pwd</span>(1) command.  (Most UNIX shells have
configurable prompts that can be coaxed into providing this same
functionality.  In fact, this is another convience setup in the default
shell for you by Slackware.)
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>pwd</code></strong>
/usr/local
</pre></div><div class="section" title="File and Directory Creation and Deletion"><div class="titlepage"><div><div><h3 class="title"><a name="id354028"></a>File and Directory Creation and Deletion</h3></div></div></div><p>
While most applications can and will create their own files and
directories, you'll often want to do this on your own.  Thankfully,
it's very easy using <span class="application">touch</span>(1) and
<span class="application">mkdir</span>(1).
</p><p>
<span class="application">touch</span> actually modifies the timestamp on a
file, but if that file doesn't exist, it will be created.
</p><pre class="screen"><code class="prompt">darkstar:~/foo$ </code><strong class="userinput"><code>ls -l</code></strong>
-rw-r--r-- 1 alan users 0 2008-01-18 15:01 bar1
<code class="prompt">darkstar:~/foo$ </code><strong class="userinput"><code>touch bar2</code></strong>
-rw-r--r-- 1 alan users 0 2008-01-18 15:01 bar1
-rw-r--r-- 1 alan users 0 2008-01-18 15:05 bar2
<code class="prompt">darkstar:~/foo$ </code><strong class="userinput"><code>touch bar1</code></strong>
-rw-r--r-- 1 alan users 0 2008-01-18 15:05 bar1
-rw-r--r-- 1 alan users 0 2008-01-18 15:05 bar2
</pre><p>
Note how <code class="filename">bar2</code> was created in our second command,
and the third command simpl updated the timestamp on
<code class="filename">bar1</code>
</p><p>
<span class="application">mkdir</span> is used for (obviously enough) making
directories.  <strong class="userinput"><code>mkdir foo</code></strong> will create the
directory "foo" within the current working directory.  Additionally,
you can use the  [-p] argument to create any
missing parent directories.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>mkdir foo</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>mkdir /slack/foo/bar/</code></strong>
mkdir: cannot create directory `/slack/foo/bar/': No such file or directory
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>mkdir -p /slack/foo/bar/</code></strong>
</pre><p>
In the latter case, <span class="application">mkdir</span> will first create
"/slack", then "/slack/foo", and finally "/slack/foo/bar".  If you
failed to use the  [-p] argument,
<span class="application">man</span> would fail to create "/slack/foo/bar"
unless the first two already existed, as you saw in the example.
</p><p>
Removing a file is as easy as creating one.  The
<span class="application">rm</span>(1) will remove a file (assuming of course
that you have permission to do this).  There are a few very common
arguments to <span class="application">rm</span>.  The first is
 [-f] and is used to force the removal of a file
that you may lack explicit permission to delete.  The
 [-r] argument will remove directories and their
contents recursively.
</p><p>
There is another tool to remove directories, the humble
<span class="application">rmdir</span>(1).  <span class="application">rmdir</span>
will only remove directories that are empty, and complain noisely about
those that contain files or sub-directories.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls</code></strong>
foo_1/ foo_2/
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls foo_1</code></strong>
bar_1
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>rmdir foo_1</code></strong>
rmdir: foo/: Directory not empty
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>rm foo_1/bar</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>rmdir foo_1</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls foo_2</code></strong>
bar_2/
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>rm -fr foo_2</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls</code></strong>
</pre></div></div><div class="section" title="Reading Documents"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id354344"></a>Reading Documents</h2></div></div></div><p>
Traditionally, UNIX and UNIX-like operating systems are filled with
text files that at some point in time the system's users are going to
want to read.  Naturally, there are plenty of ways of reading these
files, and we'll show you the most common ones.
</p><p>
In the early days, if you just wanted to see the contents of a file
(any file, whether it was a text file or some binary program) you would
use <span class="application">cat</span>(1) to view them.
<span class="application">cat</span> is a very simple program, which takes
one or more files, concatenates them (hence the name) and sends them to
the standard output, which is usually your terminal screen.  This was
fine when the file was small and wouldn't scroll off the screen, but
inadequate for larger files as it had no built-in way of moving within
a document and reading it a paragraph at a time.  Today,
<span class="application">cat</span> is still used quite extensively, but
predominately in scripts or for joining two or more files into one.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat /etc/slackware-version</code></strong>
Slackware 12.0.0
</pre><p>
Given the limitations of <span class="application">cat</span> some very
intelligent people sat down and began to work on an application to let
them read documents one page at a time.  Naturally, such applications
began to be known as "pagers".  One of the earliest of these was
<span class="application">more</span>(1), named because it would let you see
"more" of the file whenever you wanted.  <span class="application">more</span>
will display the first few lines of a text file until your screen is
full, then pause.  Once you've read through that screen, you can
proceed down one line by pressing ENTER, or an entire screen by
pressing SPACE.  <span class="application">more</span> is also capable of
searching through a text file for keywords.  Once you've displayed a
file in <span class="application">more</span>, simply press the / key and
enter a keyword.  Upon pressing ENTER, the text will scroll until it
finds the next match.  This is clearly a big improvement over
<span class="application">cat</span>, but still suffers from a serious flaw:
<span class="application">more</span> is not able to scroll back up through
the file to allow you to read something you might have missed.  Clearly
a better solution is called for.
</p><p>
In order to address the short-comings of
<span class="application">more</span>, a new pager was developed and
ironically dubbed <span class="application">less</span>(1).
<span class="application">less</span> is a very powerful pager that supports
all of the functions of <span class="application">more</span> while adding
lots of additional features.  To begin with,
<span class="application">less</span> allows you to use your arrow keys to
controll movement within the document.  Due to its popularity, many
Linux distributions have begun to exclude
<span class="application">more</span> in favor of
<span class="application">less</span>.  Slackware includes both.  Moreover,
Slackware also includes a handy little pre-processor for
<span class="application">less</span> called
<code class="filename">lesspipe.sh</code>.  This allows a user to exectute
<span class="application">less</span> on a number of non-text files.
<code class="filename">lesspipe.sh</code> will generate text output from running
a command on these files, and display it in
<span class="application">less</span>.
</p></div><div class="section" title="Linking"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id354528"></a>Linking</h2></div></div></div><p>
Links are a method of referring to one file by more than one name.  By
using the <span class="application">ln</span>(1) application, a user can
reference one file with more than one name.  The two files are not
carbon-copies of one another, but rather are the exact same file, just
with a different name.  To remove the file entirely, all of its names
must be deleted.  (This is actually the result of the way that
<span class="application">rm</span> and other tools like it work.  Rather
than remove the contents of the file, they simply remove the reference
to the file, freeing that space to be re-used.
<span class="application">ln</span> will create a second reference or "link"
to that file.)
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ln /etc/slackware-version foo</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat foo</code></strong>
Slackware 12.0.0
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls -l /etc/slackware-version foo</code></strong>
-rw-r--r-- 1 root root 17 2007-06-10 02:23 /etc/slackware-version
-rw-r--r-- 1 root root 17 2007-06-10 02:23 foo
</pre><p>
Another type of link exists, the symlink.  Symlinks, rather than being
another reference to the same file, are actually a special kind of file
in their own right.  These symlinks point to another file or directory.
The primary advantage of symlinks is that they can refer to directories
as well as files, and they can span multiple filesystems.  These are
created with the [-s] argument.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ln -s /etc/slackware-version foo</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat foo</code></strong>
Slackware 12.0.0
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls -l /etc/slackware-version foo</code></strong>
-rw-r--r-- 1 root root 17 2007-06-10 02:23 /etc/slackware-version
lrwxrwxrwx 1 root root 22 2008-01-25 04:16 foo -&gt; /etc/slackware-version
</pre><p>
When using symlinks, remember that if the original file is deleted,
your symlink is useless; it simply points at a file that doesn't exist
anymore.
</p></div></div><div class="chapter" title="Chapter 5. The Bourne Again Shell"><div class="titlepage"><div><div><h2 class="title"><a name="id336592"></a>Chapter 5. The Bourne Again Shell</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id282479">What Is A Shell?</a></span></dt><dt><span class="section"><a href="#id314358">Environment Variables</a></span></dt><dt><span class="section"><a href="#id313824">Wildcards</a></span></dt><dt><span class="section"><a href="#id335881">Tab Completion</a></span></dt><dt><span class="section"><a href="#id354670">Input and Output Redirection</a></span></dt><dt><span class="section"><a href="#id354937">Terminals</a></span></dt><dt><span class="section"><a href="#id355019">Customization</a></span></dt></dl></div><div class="section" title="What Is A Shell?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id282479"></a>What Is A Shell?</h2></div></div></div><p>
Yeah, what exactly is a shell?  Well, a shell is basically a
command-line user environment.  In essence, it is an application that
runs when the user logs in and allows him to run additional
applications.  In some ways it is very similar to a graphical user
interface, in that it provides a framework for executing commands and
launching programs.  There are many shells included with a full install
of Slackware, but in this book we're only going to discuss
<span class="application">bash</span>(1), the Bourne Again Shell. Advanced
users might want to consider using the powerful
<span class="application">zsh</span>(1), and users familiar with older UNIX
systems might appreciate <span class="application">ksh</span>. The truly
masochistic might choose the <span class="application">csh</span>, but new
users should stick to <span class="application">bash</span>.
</p></div><div class="section" title="Environment Variables"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id314358"></a>Environment Variables</h2></div></div></div><p>
All shells make certain tasks easier for the user by keeping track of
things in environment variables.  An environment variable is simply a
shorter name for some bit of information that the user wishes to store
and make use of later.  For example, the environment variable PS1 tells
<span class="application">bash</span> how to format its prompt.  Other
variables may tell applications how to run.  For example, the LESSOPEN
variable tells <span class="application">less</span> to run that handy
<code class="filename">lesspipe.sh</code> preprocessor we talked about, and
LS_OPTIONS tuns on color for <span class="application">ls</span>.
</p><p>
Setting your own envirtonment variables is easy.
<span class="application">bash</span> includes two built-in functions for
handling this: <span class="application">set</span> and
<span class="application">export</span>.  Additionally, an environment
variable can be removed by using <span class="application">unset</span>.
(Don't panic if you accidently unset an environment variable and don't
know what it would do.  You can reset all the default variables by
logging out of your terminal and logging back in.)  You can reference a
variable by placing a dollar sign ($) in front of it.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>set FOO=bar</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo $FOO</code></strong>
bar
</pre><p>
The primary difference between <span class="application">set</span> and
<span class="application">export</span> is that
<span class="application">export</span> will (naturally) export the variable
to any sub-shells.  (A sub-shell is simply another shell running inside
a parent shell.)  You can easily see this behavior when working with
the PS1 variable that controls the <span class="application">bash</span>
prompt.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>set PS1='FOO '</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>export PS1='FOO '</code></strong>
<code class="prompt">FOO </code>
</pre><p>
There are many important environment variables that
<span class="application">bash</span> and other shells use, but one of the
most important ones you will run across is PATH.  PATH is simply a list
of directories to search through for applications.  For example,
<span class="application">top</span> is located at
<span class="application">/usr/bin/top</span>(1).  You could run it simply by
specifying the complete path to it, but if
<code class="filename">/usr/bin</code> is in your PATH variable,
<span class="application">bash</span> will check there if you don't specify a
complete path one your own.  You will most likely first notice this
when you attempt to run a program that is not in your PATH as a normal
user, for instance, <span class="application">ifconfig</span>(8).
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ifconfig</code></strong>
bash: ifconfig: command not found
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo $PATH</code></strong>
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/opt/www/htdig/bin:.
</pre><p>
Above, you see a typical PATH for a mortal user.  You can change it on
your own the same as any other environment variable.  If you login as
root however, you'll see that root has a different PATH.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>su -</code></strong>
Password: 
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>echo $PATH</code></strong>
/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/opt/www/htdig/bin
</pre></div><div class="section" title="Wildcards"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id313824"></a>Wildcards</h2></div></div></div><p>
Wildcards are special characters that tell the shell to match certain
criteria.  If you have experience with DOS, you'll recognize * as a
wildcard that matches anything.  <span class="application">bash</span> makes
use of this wildcard and several others to enable you to easily define
exactly what you want to do.
</p><p>
This first and most common of these is, of course, *.  The asterisk
matches any character or combination of characters, including none.
Thus <strong class="userinput"><code>b*</code></strong> would match any files named b, ba, bab,
babc, bcdb, and so forth.  Slightly less common is the ?.  This
wildcard matches one instance of any character, so
<strong class="userinput"><code>b?</code></strong> would match ba and bb, but not b or bab.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>touch b ba bab</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls *</code></strong>
b ba bab
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls b?</code></strong>
ba
</pre><p>
No, the fun doesn't stop there!  In addition to these two we also have
the bracket pair "[ ]" which allows us to fine tune exactly what we
want to match.  Whenever <span class="application">bash</span> see the
bracket pair, it substitues the contents of the bracket.  Any
combination of letters or numbers may be specified in the bracket as
long as they are comma seperacted.  Additionally, ranges of numbers and
letters may be specified as well.  This is probably best shown by
example.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls a[1-4,9]</code></strong>
a1 a2 a3 a4 a9
</pre><p>
Since Linux is case-sensitive, capital and lower-case letters are
treated differently.  All capital letters come before all lower-case
letters in "alphabetical" order, so when using ranges of capital and
lower-case letters, make sure to get them right.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls 1[W-b]</code></strong>
1W 1X 1Y 1Z 1a 1b
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls 1[w-B]</code></strong>
/bin/ls: cannot access 1[b-W]: No such file or directory
</pre><p>
In the second example, 1[b-W] isn't a valid range, so the shell treats
it as a filename, and since that file doesn't exist,
<span class="application">ls</span> tells you so.
</p></div><div class="section" title="Tab Completion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id335881"></a>Tab Completion</h2></div></div></div><p>
Still think there's entirely too much work involved with using
wildcards?  You're right.  There's an even easier way when you're
dealing with long filenames: tab completion.  Tab completion enables
you to type just enough of the filename to uniquely identify it, then
by hitting the TAB key, <span class="application">bash</span> will fill in
the rest for you.  Even if you haven't typed in enough text to uniquely
identify a filename, the shell will fill in as much as it can for you.
Hitting TAB a second time will make it display a list of all possible
matches for you.
</p></div><div class="section" title="Input and Output Redirection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id354670"></a>Input and Output Redirection</h2></div></div></div><p>
One of the defining features of Linux and other UNIX-like operating
systems is the number of small, relatively simple applications and the
ability to stack them together to create complex systems.  This is
achieved by redirecting the output of one program to another, or by
drawing input from a file or second program.
</p><p>
To get started, we're going to show you how to redirect the output of a
program to a file.  This is easily done with the '&gt;' character.  When
<span class="application">bash</span> sees the '&gt;' character, it redirects
all of the standard output (also known as stdout) to whatever file name
follows.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo foo</code></strong>
foo
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo foo &gt; /tmp/bar</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat /tmp/bar</code></strong>
foo
</pre><p>
In this example, we show you what <span class="application">echo</span> would
do if its stdout was not redirected to a file, then we re-direct it to
the <code class="filename">/tmp/bar</code> file.  If <code class="filename">/tmp/bar</code>
does not exist, it is created and the output from
<span class="application">echo</span> is placed within it.  If
<code class="filename">/tmp/bar</code> did exist, then its contents are
over-written.  This might not be the best idea if you want to keep
those contents in place.  Thankfully, <span class="application">bash</span>
supports '&gt;&gt;' which will append the output to the file.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo foo</code></strong>
foo
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo foo &gt; /tmp/bar</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat /tmp/bar</code></strong>
foo
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>echo foo2 &gt;&gt; /tmp/bar</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat /tmp/bar</code></strong>
foo
foo2
</pre><p>
You can also re-direct the standard error (or stderr) to a file.  This
is slightly different in that you must use '2&gt;' instead of just '&gt;'.
(Since <span class="application">bash</span> can re-direct input, stdout, and
stderr, each must be uniquely identifiable.  0 is input, 1 is stdout,
and 2 is stderr.  Unless one of these is specified,
<span class="application">bash</span> will make its best guess as to what you
actually meant, and assumed anytime you use '&gt;' you only want to
redirect stdout.  1&gt; would have worked just as well.)
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>rm bar</code></strong>
rm: cannot remove `bar': No such file or directory
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>rm bar 2&gt; /tmp/foo</code></strong>
<code class="prompt">darkstar:~$ </code><strong class="userinput"><code>cat /tmp/foo</code></strong>
rm: cannot remove `bar': No such file or directory
</pre><p>
You may also redirect the standard input (known as stdin) with the
'&lt;'
character, though it's not used very often.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>fromdos &lt; dosfile </code></strong>
</pre><p>
Finally, you can actually redirect the output of one program as input
to another.  This is perhaps the most useful feature of
<span class="application">bash</span> and other shells, and is accomplished
using the '|' character.  (This character is referred to as 'pipe'.
If you here some one talk of piping one program to another, this is
exactly what they mean.)
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ps auxw | grep getty</code></strong>
root      2632  0.0  0.0   1656   532 tty2     Ss+  Feb21   0:00 /sbin/agetty 38400 tty2 linux
root      3199  0.0  0.0   1656   528 tty3     Ss+  Feb15   0:00 /sbin/agetty 38400 tty3 linux
root      3200  0.0  0.0   1656   532 tty4     Ss+  Feb15   0:00 /sbin/agetty 38400 tty4 linux
root      3201  0.0  0.0   1656   532 tty5     Ss+  Feb15   0:00 /sbin/agetty 38400 tty5 linux
root      3202  0.0  0.0   1660   536 tty6     Ss+  Feb15   0:00 /sbin/agetty 38400 tty6 linux
</pre></div><div class="section" title="Terminals"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id354937"></a>Terminals</h2></div></div></div><p>
Slackware Linux and other UNIX-like operating systems allow users to
interact with them in many ways, but the most common, and arguably the
most useful, is the terminal. In the old days, terminals were keyboards
and monitors (sometimes even mice) wired into a mainframe or server via
serial connections. Today however, most terminals are virtual; that is,
they exist only in software.  Virtual terminals allow users to connect
to the computer without requiring expensive and often incompatabile
hardware. Rather, a user needs only to run the software and they are
presented with a (usually) highly customizable virtual terminal.
</p><p>
The most common virtual terminals (in that every Slackware Linux machine
is going to have at least one) are the gettys.
<span class="application">agetty</span>(8) runs six instances by default on
Slackware, and allows local users (those who can physically sit down in
front of the computer and type at the keyboard) to login and run
applications. Each of these gettys is available on different tty
devices that are accessible seperately by pressing the
<span class="keycap"><strong>ALT</strong></span> key and one of the function keys from
<span class="keycap"><strong>F1</strong></span> through <span class="keycap"><strong>F6</strong></span>. Using these gettys
allows you to login multiple times, perhaps as different users, and run
applications in those users' shells silmutaneously. This is most
commonly done with servers which do not have
<span class="application">X</span> installed, but can be done on any machine.
</p><p>
On desktops, laptops, and other workstations where the user prefers a
graphical interface provided by <span class="application">X</span>, most
terminals are graphical.  Slackware includes many different graphical
terminals, but the most commonly used are KDE's
<span class="application">konsole</span> and XFCE's
<span class="application">Terminal</span>(1) as well as the old standby,
xterm(1). If you are using a graphical interface, check your tool bars
or menus. Each desktop environment or window manager has a virtual
terminal (often called a terminal emulater), and they are all labelled
differently. Typically though, you will find them under a "System"
sub-menu in desktop environments. Executing any of these will give you
a graphical terminal and automatically run your default shell.
</p></div><div class="section" title="Customization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id355019"></a>Customization</h2></div></div></div><p>
By now you should be pretty familiar with
<span class="application">bash</span> and you may have even noticed some odd
behavior. For example, when you login at the console, you're presented
with a prompt that looks a bit like this.
</p><pre class="screen"><code class="prompt">alan@darkstar:~$ </code></pre><p>
However, sometimes you'll see a much less helpful prompt like this one.
</p><pre class="screen"><code class="prompt">bash-3.1$ </code></pre><p>
The cause here is a special environment variable that controls the
<span class="application">bash</span> prompt. Some shells are considered
"login" shells and others are "interactive" shells, and both types read
different configuration files when started. Login shells read
<code class="filename">/etc/profile</code> and
<code class="filename">~/.bash_profile</code> when executed. Interactive shells
read <code class="filename">~/.bashrc</code> instead. This has some advantages
for power users, but is a common annoyance for many new users who want
the same environment anytime they execute
<span class="application">bash</span> and don't care about the difference
between login and interactive shells. If this applies to you, simply
edit your own ~/.bashrc file and include the following lines.
(For more information on
the different configuration files used, read the INVOCATION section of
the <span class="application">bash</span> man page.)
</p><pre class="screen">
# ~/.bashrc
. /etc/profile
. ~/.bash_profile
</pre><p>
When using the above, all your login and interactive shells will have
the same environment settings and behave identically. Now, anytime we
wish to customize a shell setting, we only have to edit
<code class="filename">~/.bash_profile</code> for user-specific changes and
<code class="filename">/etc/profile</code> for global settings. Let's start by
configuring the prompt.
</p><p>
<span class="application">bash</span> prompts come in all shapes, colors, and
sizes, and every user has their own preferances. Personally, I prefer
short and simple prompts that take up a minimum of space, but I've seen
and used mutli-line prompts many times. One personal friend of mine
even included ASCII-art in his bash prompt. To change your prompt you
need only to change your PS1 variable. By default, Slackware attempts
to configure your PS1 variable thusly:
</p><pre class="screen"><code class="prompt">darkstar:~$ </code>echo $PS1
\u@\h:\w\$ </pre><p>
Yes, this tiny piece of funny-looking figures controls your
<span class="application">bash</span> prompt. Basicaly, every character in
the PS1 variable is included in the prompt, unless it is a escaped by a
<span class="keycap"><strong>\</strong></span>, which tells <span class="application">bash</span> to
interpret it. There are many different escape sequences and we can't
discuss them all, but I'll explain these.  The first "\u" translates to
the username of the current user.  "\h" is the hostname of the machine
the terminal is attached to. "\w" is the current working directory, and
"\$" displays either a <span class="keycap"><strong>#</strong></span> or a <span class="keycap"><strong>$</strong></span> sign,
depending on whether or not the current user is root.  A complete
listing of all prompt escape sequences is listed in the
<span class="application">bash</span> man page under the PROMPTING section.
</p><p>
Since we've gone through all this trouble to discuss the default
prompt, I thought I'd take some time to show you a couple example
prompts and the PS1 variable values needed to use them.
</p><pre class="screen"><code class="prompt">Wed Jan 14 12:08 AM
alan@raven:~$ </code>echo $PS1
\d \@\n\u@\h:\w$ 
<code class="prompt">HOST: raven - JOBS: 0 - TTY: 3
alan@~/Desktop/sb_3.0:$ </code>echo $PS1
HOST: \H - JOBS: \j - TTY: \l\n\u@\w:\$
</pre><p>
For even more information on configuring your bash prompt, including
information on setting up colored prompts, refer to
<code class="filename">/usr/doc/Linux-HOWTOs/Bash-Prompt-HOWTO</code>. After
reading that for a short while, you'll get an idea of just how powerful
your <span class="application">bash</span> prompts can be. I once even had a
prompt that gave me up to date weather information such as temperature
and barometric pressure!
</p></div></div><div class="chapter" title="Chapter 6. The X Window System"><div class="titlepage"><div><div><h2 class="title"><a name="id325945"></a>Chapter 6. The X Window System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id358884">What Is (And Isn't) X</a></span></dt><dt><span class="section"><a href="#id320754">Configuring the X Server</a></span></dt><dt><span class="section"><a href="#id314642">Choosing a Window Manager</a></span></dt><dt><span class="section"><a href="#id351028">Setting Up A Graphical Login</a></span></dt></dl></div><div class="section" title="What Is (And Isn't) X"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id358884"></a>What Is (And Isn't) X</h2></div></div></div><p>
Eons ago computer terminals came with a screen and a keyboard and not
much else. Mice hadn't come into common use and everything was menu
driven. Then came the Graphical User Interface (GUI) and the world was
changed. Today users are accustomed to moving a mouse around a screen,
clicking on icons and running tasks with fancy images and animation,
but UNIX systems predated this and so GUIs were added almost as an
afterthought. For many years, Linux and its UNIX brethren were
primarily used without graphics of any sort, but today it is perhaps
more common than not for users to prefer their Linux computers come
with shiney, flashy, clickable GUIs, and all these GUIs run on
<span class="application">X</span>(7).
</p><p>
So what is X? Is it the desktop with the icons? Is it the menus? Is it
the window manager? Does it mark the spot? The answer to all these is a
resounding "no". There are many parts to a GUI, but X is the most
fundamental. X is that application that receives input from the mouse,
keyboard, and possibly other devices. X is that application that tells
the graphics card what to do. In short, X is the application that talks
to your computer's hardware from graphical purposes; all other
graphical applications simply talk to X.
</p><p>
Let's stop for a moment and talk about nomenclature. X is just one of a
dozen names that you may encounter. It is also called X11, the X Window
System, X Window, X11R6, X Version 11, and several others. Whatever
you hear it called, simply understand that the speakers are referring
to X.
</p></div><div class="section" title="Configuring the X Server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id320754"></a>Configuring the X Server</h2></div></div></div><p>
As powerful as Slackware Linux is, configuring X can be daunting and
is often one of the first real challenges a new user faces. Don't be
overly concerned if you find this a bit difficult. While many changes
have been made over the years that make this much easier, there are
still computers out there that don't properly auto-detect, or you'll
wish to make some change to some setting and it might not be immediately
apparent what to do. Just remember that when I started using X, it was
far more primitive than it is today, took far more work to configure,
and often crashed without telling the user what was wrong. If I and
thousands of others got this working back then, you can do it today.
Fortunately, Slackware includes a default configuration file that works
for most computers by using the VESA standard. This offers only the
most basic functions and may not allow your graphics card to operate at
its full potential. You may be limited to low resolutions, fewer
colors, and <span class="application">X</span> will be slower. Still, this is
an option for users, particularly those who only want to occassionally
run <span class="application">X</span>. You can try it out now simply by
running <span class="application">startx</span>(1) from a command prompt.
</p><p>
There are many ways to configure <span class="application">X</span>, but the
easiest is to use <span class="application">xorgsetup</span>. This will attempt
to probe probe your computer's hardware and write a working xorg.conf
file. This option is not garaunteed to work; there are some platforms
that it is known not to work with, and there are probably others as
well. Still, it is worth trying first as it is the quickest and least
complicated for a new user to attempt.
</p><p>
The second most popular way to configure <span class="application">X</span>
on your system is the handy <span class="application">xorgconfig</span>(1).
This application asks you a series of questions about your computer's
hardware and writes out a config file based on your choices. Unless you
know exactly what your hardware is, we recommend that you try
<span class="application">xorgsetup</span> first.
</p><p>
Lastly, you can manually configure your <span class="application">X</span>
server by modifying <code class="filename">/etc/X11/xorg.conf</code> with a text
editor. This is not normally a task for the faint of heart, but is
often the easiest way to make minor changes.
</p></div><div class="section" title="Choosing a Window Manager"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id314642"></a>Choosing a Window Manager</h2></div></div></div><p>
Slackware Linux includes many different window managers and desktop
environments. Window managers are the applications responsible for
painting application windows on the screen, resizing these windows, and
similar tasks. Desktop environments include a window manager, but also
add task bars, menus, icons, and more. Slackware includes both the KDE
and XFCE desktop environments and several additional window managers.
Which you use is entirely your own decision, but in general, window
managers tend to be faster than desktop environments and more suitable
to older systems with less memory and slower processors. Desktop
environments will be more comfortable for users accustomed to Microsoft
Windows.
</p><p>
LIST OF DE'S AND WINDOW MANAGERS.
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
FILL THIS IN!!!!
</p><p>
The easiest way to choose a window manager is
<span class="application">xwmconfig</span>(1), included with Slackware Linux.
This application allows a user to choose what window manager to run
with <span class="application">startx</span>. 
</p></div><div class="section" title="Setting Up A Graphical Login"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id351028"></a>Setting Up A Graphical Login</h2></div></div></div><p>
By default, when you boot your Slackware Linux system you are presented
with a login prompt on a virtual terminal. This is more than adequate
for most people's needs. If you need to run commandline applications,
you may login and do so right away. If you want to run X, simply executing
<span class="application">startx</span> will do that for you nicely.
But suppose you almost exclusively
use your system for graphical duties like many laptop owners? Wouldn't
it be nice for Slackware to take you straight into a GUI? Fortunately,
there's an easy way to do just that.
</p><p>
Slackware uses the System V init system which allows the administrator
to boot into or change to different runlevels, which are really just
different "states" the computer can be in. In fact, shutting down the
computer is really only a case of changing to a runlevel which
accomplishes just that. Runlevels can be rather complicated, so we
won't delve into them any further than necessary.
</p><p>
Runlevels are configured in <code class="filename">inittab</code>(5).
The most common ones are
runlevel 3 (Slackware's default) and runlevel 4 (GUI). In order to tell
Slackware to boot to a GUI screen, simply open
<code class="filename">/etc/inittab</code> with your
favorite editor of choice. (You may wish to refer to one of the
chapters on <span class="application">vi</span> or
<span class="application">emacs</span> at this point.) Near the top, you'll
see the relevant entries. 
</p><pre class="screen">
# These are the default runlevels in Slackware:
#   0 = halt
#   1 = single user mode
#   2 = unused (but configured the same as runlevel 3)
#   3 = multiuser mode (default Slackware runlevel)
#   4 = X11 with KDM/GDM/XDM (session managers)
#   5 = unused (but configured the same as runlevel 3)
#   6 = reboot

# Default runlevel. (Do not set to 0 or 6)
id:3:initdefault:
</pre><p>
In this file (along with most configuration files) anything following a
hash symbol # is a comment and not interpreted by init(8). Don't worry
if you don't understand everything about inittab, as many veteran users
don't either. The only line we are interested in is the last on above.
Simply change the 3 to a 4 and reboot.
</p><pre class="screen">
# These are the default runlevels in Slackware:
#   0 = halt
#   1 = single user mode
#   2 = unused (but configured the same as runlevel 3)
#   3 = multiuser mode (default Slackware runlevel)
#   4 = X11 with KDM/GDM/XDM (session managers)
#   5 = unused (but configured the same as runlevel 3)
#   6 = reboot

# Default runlevel. (Do not set to 0 or 6)
id:4:initdefault:
</pre></div></div><div class="chapter" title="Chapter 7. Printing"><div class="titlepage"><div><div><h2 class="title"><a name="id292994"></a>Chapter 7. Printing</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id337782">Choosing A Printer</a></span></dt><dt><span class="section"><a href="#id357050">Setting Up a Printer in CUPS</a></span></dt><dt><span class="section"><a href="#id322037">Commandline Printing Tools</a></span></dt></dl></div><div class="section" title="Choosing A Printer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id337782"></a>Choosing A Printer</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Setting Up a Printer in CUPS"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id357050"></a>Setting Up a Printer in CUPS</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Commandline Printing Tools"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id322037"></a>Commandline Printing Tools</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div></div><div class="chapter" title="Chapter 8. Users and Groups"><div class="titlepage"><div><div><h2 class="title"><a name="id337784"></a>Chapter 8. Users and Groups</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id359209">What Are Users and Groups?</a></span></dt><dt><span class="section"><a href="#id341153">Managing Users and Groups</a></span></dt><dt><span class="section"><a href="#id359270">Other User and Group Tools</a></span></dt><dt><span class="section"><a href="#id321249">Managing Users and Groups Manually</a></span></dt></dl></div><div class="section" title="What Are Users and Groups?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id359209"></a>What Are Users and Groups?</h2></div></div></div><p>
Slackware Linux inherits a strong multi-user tradition from its UNIX
inspiration. This means that multiple people may use the system at
once, but it also means that each of these people may have different
permissions. This allows users to prevent others from modifying their
files, or lets system administrators explicitly define what users can
and cannot do on the system. Moreover, users need not be actual people
at all. In fact, Slackware includes several dozen pre-defined user
and group accounts that are not typically used by regular users. Rather
these accounts allow the system administrator to segment the system for
security reasons. We'll see how that's done in the next chapter on
filesystem permissions.
</p></div><div class="section" title="Managing Users and Groups"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id341153"></a>Managing Users and Groups</h2></div></div></div><p>
The easiest way to add new users in Slackware is through the use of our
very fine <span class="application">adduser</span> shell script.
<span class="application">adduser</span> will prompt you to enter the details
of the new user you wish to creature and step you through the process
quickly and easily. It will even create a password for the new user.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>adduser</code></strong>

Login name for new user []: <strong class="userinput"><code>david</code></strong>

User ID ('UID') [ defaults to next available ]: 

Initial group [ users ]: 
Additional UNIX groups:

Users can belong to additional UNIX groups on the system.
For local users using graphical desktop login managers such
as XDM/KDM, users may need to be members of additional groups
to access the full functionality of removable media devices.

* Security implications *
Please be aware that by adding users to additional groups may
potentially give access to the removable media of other users.

If you are creating a new user for remote shell access only,
users do not need to belong to any additional groups as standard,
so you may press ENTER at the next prompt.

Press ENTER to continue without adding any additional groups
Or press the UP arrow to add/select/edit additional groups
:  <strong class="userinput"><code>audio cdrom floppy plugdev video</code></strong>

Home directory [ /home/david ] 

Shell [ /bin/bash ] 

Expiry date (YYYY-MM-DD) []: 

New account will be created as follows:

---------------------------------------
Login name.......:  david
UID..............:  [ Next available ]
Initial group....:  users
Additional groups:  audio,cdrom,floppy,plugdev,video
Home directory...:  /home/david
Shell............:  /bin/bash
Expiry date......:  [ Never ]

This is it... if you want to bail out, hit Control-C.  Otherwise, press
ENTER to go ahead and make the account.


Creating new account...


Changing the user information for david
Enter the new value, or press ENTER for the default
	Full Name []: 
	Room Number []: 
	Work Phone []: 
	Home Phone []: 
	Other []: 
Changing password for david
Enter the new password (minimum of 5, maximum of 127 characters)
Please use a combination of upper and lower case letters and numbers.
New password: 
Re-enter new password: 
Password changed.


Account setup complete.
</pre><p>
The addition of optional groups needs a little explaining. Every user
in Slackware has a single group that it is always a member of. By
default, this is the "users" group. However, users can belong to more
than one group at a time and will inherit all the permissions of every
group they belong to. Typical desktop users will need to add several
group memberships in order to do things like play sound or access
removeable media like cdroms or USB flash drives. You can simply press
the up arrow key at this section and a list of default groups for
desktop users will magically appear. You can of course, add to or
remove groups from this listing.
</p><p>
Now that we've demonstrated how to use the interactive
<span class="application">adduser</span> program, lets look at some powerful
non-interactive tools that you may wish to use. The first is
<span class="application">useradd</span>(8).
<span class="application">useradd</span> is a little less friendly, but much
faster for creating users in batches. This makes it ideal for use in
shell scripts. In fact, <span class="application">adduser</span> is just such
a shell script and uses <span class="application">useradd</span> for most of
the heavy lifting. <span class="application">useradd</span> has many options
and we can't explain them all here, so refer to its man page for the
complete details. Now, let's make a new user.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>useradd -d /data/home/alan -s /bin/bash -g users -G audio,cdrom,floppy,plugdev,video alan</code></strong>
</pre><p>
Here I have added the user "alan". I specified the user's home
directory as <code class="filename">/data/home/alan</code> and used
<span class="application">bash</span> as my shell. Also, I specified my
default group as "users" and added myself to a number of useful groups
for dekstop use.  You'll note that <span class="application">useradd</span>
does not do any prompting like <span class="application">adduser</span>.
Unless you want to accept the defaults for everything, you'll need to
tell <span class="application">useradd</span> what to do.
</p><p>
Now that we know how to add users, we should learn how to add groups.
As you might have guessed, the command for doing this is
<span class="application">groupadd</span>(8).
<span class="application">groupadd</span> works in the same way as
<span class="application">useradd</span>, but with far fewer options. The
following command adds the group "slackers" to the system.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>groupadd slackers</code></strong>
</pre><p>
Deleting users and groups is easy as well. Simply run the
<span class="application">userdel</span>(8) and
<span class="application">groupdel</span>(8) commands. By default,
<span class="application">userdel</span> will leave the user's home directory
on the system. You can remove this with the  [-r] argument.
</p></div><div class="section" title="Other User and Group Tools"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id359270"></a>Other User and Group Tools</h2></div></div></div><p>
Several other tools exist for managing users and groups. Perhaps the
most important one is <span class="application">passwd</span>(1). This
command changes a user account's password. Normal users may change
their own passwords only, but root can change anyone's password. Also,
root can lock a user account with the  [-l] argument. This
doesn't actually shutout the account, but instead changes the user's
encrypted password to a value that can't be matched.
</p><p>
Another useful tool is <span class="application">chsh</span>(1) which changes a
user's default shell. Like <span class="application">passwd</span>, normal
users can only change their own shell, but the root user can change
anyone's.
</p><p>
The last tool we're going to discuss is
<span class="application">chfn</span>(1). This is used to enter identifying
information on the user such as his phone number and real name. This
information is stored in the <code class="filename">passwd</code>(5) file and
retrieved using <span class="application">finger</span>(1).
</p></div><div class="section" title="Managing Users and Groups Manually"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id321249"></a>Managing Users and Groups Manually</h2></div></div></div><p>
Like most things in Slackware Linux, users and groups are stored in
plain-text files. This means that you can edit all the details of a
user, or even create a new user or group simply by editing these files
and doing a few other tasks like creating the user's home directory. Of
course, after you see how this is done you'll appreciate just how
simple the included tools make this task.
</p><p>
Our first stop is the <code class="filename">/etc/passwd</code> file. Here, all
the information about a user is stored, except for (oddly enough) the
user's password. The reason for this is rather simple.
<code class="filename">/etc/passwd</code> must be readable by all users on the
system, so you wouldn't want passwords stored there, even if they are
encrypted. Let's take a quick look at my entry in this file.
</p><pre class="screen">
alan:x:1000:100:,,,:/home/alan:/bin/bash
</pre><p>
Each line in this file contains a number of fields seperated by a
colon. They are, from left to right: username, password, UID, GUID, a
comment field, home directory, and shell. You'll notice that the
password field for every entry is an <span class="keycap"><strong>x</strong></span>. That is
because Slackware uses shadow passwords, so the actual encrypted
password is stored in <code class="filename">/etc/shadow</code>. Let's take a
look there.
</p><pre class="screen">
alan:$1$HlR?M3fkL@oeJmsdLfhsLFM*4dflPh8:14197:0:99999:7:::
</pre><p>
The <code class="filename">shadow</code> file contains more than just the
encrypted password as you'll notice. The fields here, again from left
to right, are: username, encrypted password, last day the password was
changed, days before the password may be changed again, how many days
before the password expires, days that the account will be disabled
after expiring, when the account was disabled, and a reserved field.
You may notice on some accounts that the various "days" fields often
include very large numbers. The reason for this is that Slackware
counts time from the "Epoch" which is January 1, 1970 for historical
reasons.
</p><p>
To create a new user account, you'll just need to open these files
using <span class="application">vipw</span>(8). This will open
<code class="filename">/etc/passwd</code> in the editor
defined by your VISUAL variable or your EDITOR variable if VISUAL isn't
defined. If neither is present, it will fall back to
<span class="application">vi</span> by default. If you pass the  [-s]
argument, it will open <code class="filename">/etc/shadow</code> instead. It's
important to use <span class="application">vipw</span> instead of using any
other editor, because <span class="application">vipw</span> will lock the
file and prevent other programs from editing it right underneath your feet.
</p><p>
That isn't all you'll need to do however; you must also create the
user's home directory and change the user's password using
<span class="application">passwd</span>.
</p></div></div><div class="chapter" title="Chapter 9. Filesystem Permissions"><div class="titlepage"><div><div><h2 class="title"><a name="id290832"></a>Chapter 9. Filesystem Permissions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id312644">Permissions Overview</a></span></dt><dt><span class="section"><a href="#id336783"><span class="application">chmod</span>,
<span class="application">chown</span>, and
<span class="application">chgrp</span></a></span></dt><dt><span class="section"><a href="#id342316">SUID, SGID, and the "Sticky" Bit</a></span></dt></dl></div><div class="section" title="Permissions Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id312644"></a>Permissions Overview</h2></div></div></div><p>
As we've discussed, Slackware Linux is a multi-user operating system.
Because of this, its filesystems are mutli-user as well. This means
that every file or directory has a set of permissions that can grant or
deny privileges to different users. There are three basic permissions
and three sets of permissions for each file. Let's take a look at an
example file.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls -l /bin/ls</code></strong>
-rwxr-xr-x 1 root root 81820 2007-06-08 21:12 /bin/ls
</pre><p>
Recall from chapter 4 that <span class="application">ls</span>  [-l]
lists the permissions for a file or
directory along with the user and group that "own" the file. In this
case, the permissions are rwxr-xr-x, the user is root and the group is
also root. The permissions section, while grouped together, is really
three seperate pieces. The first set of three letters are the
permissions granted to the user that owns the file. The second set of
three are those granted to the group owner, and the final three are
permissions for everyone else.
</p><div class="table"><a name="id337693"></a><p class="title"><b>Table 9.1. Permissions of /bin/ls</b></p><div class="table-contents"><table summary="Permissions of /bin/ls" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Set</th><th>Listing</th><th>Meaning</th></tr></thead><tbody><tr><td>Owner</td><td>rwx</td><td>The owner "root" may read, write, and execute</td></tr><tr><td>Group</td><td>r-x</td><td>The group "root" may read and execute</td></tr><tr><td>Others</td><td>r-x</td><td>Everyone else may read and execute</td></tr></tbody></table></div></div><br class="table-break"><p>
The permissions are pretty self explainatory of course, at least for
files. Read, write, and execute allow you to read a file, write to it,
or execute it. But what do these permissions mean for directories?
Simply put, the read permissions grants the ability to list the
directory's contents (say with <span class="application">ls</span>). The write
permission grants the ability to create new files in the directory as
well as delete the entire directory, even if you otherwise wouldn't be
able to delete some of the other files inside it. The execute
permission grants the ability to actually enter the directory (with the
<span class="application">bash</span> built-in command cd for example).
</p><p>
Let's look at the permissions on a directory now.
</p><pre class="screen"><code class="prompt">darkstar:~$ </code><strong class="userinput"><code>ls -ld /home/alan</code></strong>
drwxr-x--- 60 alan users 3040 2008-06-06 17:14 /home/alan/
</pre><p>
Here we see the permissions on my home directory and its ownership. The
directory is owned by the user alan and the group users. The user is
granted all rights (rwx), the group is granted only read and execute
permissions (r-x), and everyone else is prohibited from doing anything.
</p></div><div class="section" title="chmod, chown, and chgrp"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id336783"></a><span class="application">chmod</span>,
<span class="application">chown</span>, and
<span class="application">chgrp</span></h2></div></div></div><p>
So now that we know what permissions are, how do we change them? And
for that matter, how do we assign user and group ownership? The answer
is right here in this section.
</p><p>
The first tool we'll discuss is the useful
<span class="application">chown</span>
(1) command. Using <span class="application">chown</span>, we can (you guessed
it), change the ownership of a file or
directory.  <span class="application">chown</span> is historically used only
to change the user ownership, but can change the group ownership as well.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /tmp/foo</code></strong>
total 0
-rw-r--r-- 1 alan users 0 2008-06-06 22:29 a
-rw-r--r-- 1 alan users 0 2008-06-06 22:29 b
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>chown root /tmp/foo/a</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /tmp/foo</code></strong>
total 0
-rw-r--r-- 1 root users 0 2008-06-06 22:29 a
-rw-r--r-- 1 alan users 0 2008-06-06 22:29 b
</pre><p>
By using a colon after the user account, you may also specify a new
group account.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>chown root:root /tmp/foo/b</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code> ls -l /tmp/foo</code></strong>
total 0
-rw-r--r-- 1 root users 0 2008-06-06 22:29 a
-rw-r--r-- 1 root root  0 2008-06-06 22:29 b
</pre><p>
<span class="application">chown</span> can also be used recursively to change
the ownership of all files and directories below a target directory.
The following command would change all the files under the directory
<code class="filename">/tmp/foo</code> to have their ownership set to root:root.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>chown -R root:root /tmp/foo/b</code></strong></pre><p>
Specifying a colon and a group name without a user name will simply
change the group for a file and leave the user ownership intact.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>chown :wheel /tmp/foo/a</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /tmp/foo</code></strong>
ls -l /tmp/foo
total 0
-rw-r--r-- 1 root wheel 0 2008-06-06 22:29 a
-rw-r--r-- 1 root root  0 2008-06-06 22:29 b
</pre><p>
The younger brother of <span class="application">chown</span> is the
slightly less useful <span class="application">chgrp</span>(1). This
command works just like <span class="application">chown</span>, except
it can only change the group
ownership of a file. Since <span class="application">chown</span> can
already do this, why bother with
<span class="application">chgrp</span>? The answer is simple. Many other
operating systems use a
different version of <span class="application">chown</span> that cannot
change the group ownership, so
if you ever come across one of those, now you know how.
</p><p>
There's a reason we discussed changing ownership before changing
permissions. The first is a much easier concept to grasp. The tool for
changing permissions on a file or directory is
<span class="application">chmod</span>(1). The syntax for it
is nearly identical to that for <span class="application">chown</span>, but
rather than
specify a user or group, the administrator must specify either a set of
octal permissions or a set of alphabetic permissions. Neither one is
especially easy to grasp the first time. We'll begin with the less
complicated octal permissions.
</p><p>
Octal permissions derive their name from being assigned by one of eight
digits, namely the numbers 0 through 7. Each permissions is assigned a
number that is a power of 2, and those numbers are added together to
get the final permissions for one of the permission sets. If this
sounds confusing, maybe this table will help. 
</p><div class="table"><a name="id330724"></a><p class="title"><b>Table 9.2. Octal Permissions</b></p><div class="table-contents"><table summary="Octal Permissions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Permission</th><th>Meaning</th></tr></thead><tbody><tr><td>Read</td><td>4</td></tr><tr><td>Write</td><td>2</td></tr><tr><td>Execute</td><td>1</td></tr></tbody></table></div></div><br class="table-break"><p>
By adding these values together, we can reach any number between 0 and
7 and specify all possible permission combinations. For example, to
grant both read and write privilages while denying execute, we would
use the number 6. The number 3 would grant write and execute
permissions, but deny the ability to read the file. We must specify a
number for each of the three sets when using octal permissions. It's
not possible to specify only a set of user or group permissions this
way for example.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /tmp/foo/a</code></strong>
-rw-r--r-- 1 root root  0 2008-06-06 22:29 a
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>chmod 750 /tmp/foo/a</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /tmp/foo/a</code></strong>
-rwxr-x--- 1 root root  0 2008-06-06 22:29 a
</pre><p>
<span class="application">chmod</span> can also use letter values along with
<span class="keycap"><strong>+</strong></span> or <span class="keycap"><strong>-</strong></span> to grant or deny permissions.
While this may be easier to
remember, it's often easier to use the octal permissions. 
</p><div class="table"><a name="id342090"></a><p class="title"><b>Table 9.3. Alphabetic Permissions</b></p><div class="table-contents"><table summary="Alphabetic Permissions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Permission</th><th>Letter Value</th></tr></thead><tbody><tr><td>Read</td><td>r</td></tr><tr><td>Write</td><td>w</td></tr><tr><td>Execute</td><td>x</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="id342158"></a><p class="title"><b>Table 9.4. Alphabetic Users and Groups</b></p><div class="table-contents"><table summary="Alphabetic Users and Groups" border="1"><colgroup><col><col></colgroup><thead><tr><th>Accounts Affected</th><th>Letter Value</th></tr></thead><tbody><tr><td>User/Owner</td><td>u</td></tr><tr><td>Group</td><td>g</td></tr><tr><td>Others/World</td><td>o</td></tr></tbody></table></div></div><br class="table-break"><p>
To use the letter values with <span class="application">chmod</span>, you
must specify which set to use them with, either "u" for user, "g" for
group, and "o" for all others. You must also specify whether you are
adding or removing permissions with the "+" and "-" signs. Multiple
sets can be changed at once by seperating each with a comma.
</p><pre class="screen"><code class="prompt">darkstar:/tmp/foo# </code><strong class="userinput"><code>ls -l</code></strong>
total 0
-rw-r--r-- 1 alan users 0 2008-06-06 23:37 a
-rw-r--r-- 1 alan users 0 2008-06-06 23:37 b
-rw-r--r-- 1 alan users 0 2008-06-06 23:37 c
-rw-r--r-- 1 alan users 0 2008-06-06 23:37 d
<code class="prompt">darkstar:/tmp/foo# </code><strong class="userinput"><code>chmod u+x a</code></strong>
<code class="prompt">darkstar:/tmp/foo# </code><strong class="userinput"><code>chmod g+w b</code></strong>
<code class="prompt">darkstar:/tmp/foo# </code><strong class="userinput"><code>chmod u+x,g+x,o-r c</code></strong>
<code class="prompt">darkstar:/tmp/foo# </code><strong class="userinput"><code>chmod u+rx-w,g+r,o-r d</code></strong>
<code class="prompt">darkstar:/tmp/foo# </code><strong class="userinput"><code>ls -l</code></strong>
-rwxr--r-- 1 alan users 0 2008-06-06 23:37 a*
-rw-rw-r-- 1 alan users 0 2008-06-06 23:37 b
-rwxr-x--- 1 alan users 0 2008-06-06 23:37 c*
-r-xr----- 1 alan users 0 2008-06-06 23:37 d*
</pre><p>
Which you prefer to use is entirely up to you. There are places where
one is better than the other, so a real Slacker will know both inside
out.
</p></div><div class="section" title='SUID, SGID, and the "Sticky" Bit'><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id342316"></a>SUID, SGID, and the "Sticky" Bit</h2></div></div></div><p>
We're not quite done with permissions just yet. There are three other
"special" permissions in addition to those mentioned above. They are
SUID, SGID, and the sticky bit. When a file has one or more of these
permissions set, it behaves in special ways. The SUID and SGID
permissions change the way an application is run, while the sticky bit
restricts deletion of files. These permissions are applied with
<span class="application">chmod</span>
like read, write, and execute, but with a twist.
</p><p>
SUID and SGID stand for "Set User ID" and "Set Group ID" respectively.
When an application with one of these bits is set, the application runs
with the user or group ownership permissions of that application
regardless of what user actually 
executed it. Let's take a look at a common SUID application, the humble
<span class="application">passwd</span> and the files it modifies.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -l /usr/bin/passwd \
  /etc/passwd \
  /etc/shadow</code></strong>
-rw-r--r-- 1 root root    1106 2008-06-03 22:23 /etc/passwd
-rw-r----- 1 root shadow   627 2008-06-03 22:22 /etc/shadow
-rws--x--x 1 root root   34844 2008-03-24 16:11 /usr/bin/passwd*
</pre><p>
Notice the permissions on <span class="application">passwd</span>. Instead of
an <span class="keycap"><strong>x</strong></span> in the user's execute slot, we have an
<span class="keycap"><strong>s</strong></span>. This tells us that
<span class="application">passwd</span> is a SUID program, and when we run
it, the process will run as the user "root" rather than as the user
that actually executed it. The reason for this is readily apparent as
soon as you look at the two files it modifies. Neither
<code class="filename">/etc/passwd</code> nor <code class="filename">/etc/shadow</code>
are writeable by anyone other than root. Since users need to change
their personal information, <span class="application">passwd</span> must be
run as root in order to modify those files.
</p><p>
So what about the sticky bit? The sticky bit restricts the ability to
move or delete files and is only ever set on directories. Non-root
users cannot move or delete any files under a directory with the sticky
bit set unless they are the owner of that file. Normally anyone with
write permission to the file can do this, but the sticky bit prevents
it for anyone but the owner (and of course, root). Let's take a look at
a common "sticky" directory. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ls -ld /tmp</code></strong>
drwxrwxrwt 1 root root   34844 2008-03-24 16:11 /tmp
</pre><p>
Naturally, being a directory for the storage of temporary files sytem
wide, <code class="filename">/tmp</code> needs to be readable, writeable, and
executable by anyone and everyone. Since any user is likely to have a
file or two stored here at any time, it only makes good sense to
prevent other users from deleting those files, so the sticky bit has
been set. You can see it by the presence of the <span class="keycap"><strong>t</strong></span> in
place of the <span class="keycap"><strong>x</strong></span> in the world permissions section.
</p><div class="table"><a name="id342457"></a><p class="title"><b>Table 9.5. SUID, SGID, and "Sticky" Permissions</b></p><div class="table-contents"><table summary='SUID, SGID, and "Sticky" Permissions' border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Permission Type</th><th>Octal Value</th><th>Letter Value</th></tr></thead><tbody><tr><td>SUID</td><td>4</td><td>s</td></tr><tr><td>SGID</td><td>2</td><td>s</td></tr><tr><td>Sticky</td><td>1</td><td>t</td></tr></tbody></table></div></div><br class="table-break"><p>
When using octal permissions, you must specify an additional leading
octal value. For example, to recreate the permission on
<code class="filename">/tmp</code>, we would use 1777. To recreate those
permissions on <code class="filename">/usr/bin/passwd</code>, we would use 4711.
Essentially, any time this leading fourth octet isn't specified,
<span class="application">chmod</span> assumes its value to be 0.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>chmod 1777 /tmp</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>chmod 4711 /usr/bin/passwd</code></strong>
</pre><p>
Using the alphabetic permission values is slightly different. Assuming
the two files above have permissions of 0000 (no permissions at all),
here is how we would set them. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>chmod ug+rwx,o+rwt /tmp</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>chmod u+rws,go+x /usr/bin/passwd</code></strong>
</pre></div></div><div class="chapter" title="Chapter 10. Working with Filesystems"><div class="titlepage"><div><div><h2 class="title"><a name="id283108"></a>Chapter 10. Working with Filesystems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id325517">The Filesystem Hierarchy</a></span></dt><dt><span class="section"><a href="#id318597">Local Filesystem Types</a></span></dt><dd><dl><dt><span class="section"><a href="#id318610">ext2</a></span></dt><dt><span class="section"><a href="#id318624">ext3</a></span></dt><dt><span class="section"><a href="#id318642">reiserfs</a></span></dt><dt><span class="section"><a href="#id318656">XFS</a></span></dt><dt><span class="section"><a href="#id318671">JFS</a></span></dt><dt><span class="section"><a href="#id318685">iso9660</a></span></dt><dt><span class="section"><a href="#id318711">vfat</a></span></dt><dt><span class="section"><a href="#id355976">swap</a></span></dt></dl></dd><dt><span class="section"><a href="#id355992">Using <span class="application">mount</span></a></span></dt><dt><span class="section"><a href="#id360747">Network Filesystems</a></span></dt><dd><dl><dt><span class="section"><a href="#id360758">NFS</a></span></dt><dt><span class="section"><a href="#id360899">SMB</a></span></dt></dl></dd></dl></div><div class="section" title="The Filesystem Hierarchy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id325517"></a>The Filesystem Hierarchy</h2></div></div></div><p>
Slackware Linux stores all of its files and directories under a single
<code class="filename">/</code> directory, typically referred to as "root". This
is in stark contract to what you may be familiar with in the form of
Microsoft Windows. Different hard disk partitions, cdroms, usb flash
drives, and even floppy disks can all be mounted in directories under
<code class="filename">/</code>, but do not have anything like "drive letters".
The contents of these devices can be found almost anywhere, but there
are some sane defaults that Slackware sets up for you. For example,
cd-rw drives are most often found at <code class="filename">/mnt/cd-rw</code>.
Here are a few common directories present on nearly all Slackware Linux
installations, and what you can expect to find there. 
</p><div class="table"><a name="id336627"></a><p class="title"><b>Table 10.1. Filesystem Layout</b></p><div class="table-contents"><table summary="Filesystem Layout" border="1"><colgroup><col><col></colgroup><thead></thead><tbody><tr><td>/</td><td>The root directory, under which all others exist</td></tr><tr><td>/bin</td><td>Minimal set of binary programs for all users</td></tr><tr><td>/boot</td><td>The kernel, initrd, and other requirements for booting Slackware</td></tr><tr><td>/etc/</td><td>System configuration files</td></tr><tr><td>/dev</td><td>Collection of special files allowing direct access to hardware</td></tr><tr><td>/home</td><td>User directories where personal files and settings are stored</td></tr><tr><td>/media</td><td>Directory for auto-mounting features in DBUS/HAL</td></tr><tr><td>/mnt</td><td>Places to temporarily mount removable media</td></tr><tr><td>/opt</td><td>Directory where some (typicaly proprietary) software may be installed</td></tr><tr><td>/proc</td><td>Kernel exported filesystem for process information</td></tr><tr><td>/root</td><td>The root user's home directory</td></tr><tr><td>/sbin</td><td>Minimal set of system or superuser binaries</td></tr><tr><td>/srv</td><td>Site-specific data such as web pages served by this system</td></tr><tr><td>/sys</td><td>Special kernel implimentation details</td></tr><tr><td>/tmp</td><td>Directory reserved for temporary files for all users</td></tr><tr><td>/usr</td><td>All non-essential programs, libraries, and shared files</td></tr><tr><td>/var</td><td>Regularly changing data such as log files</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Local Filesystem Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id318597"></a>Local Filesystem Types</h2></div></div></div><p>
The Linux kernel supports a wide variety of filesystems, which allows
you to choose from a long list of features to tailor to your particular
need. Fortunately, most of the default filesystem types are adequate
for any needs you may have. Some filesystems are geared towards
particular media. For example, the iso9660 filesystem is used almost
exclusively for CD and DVD media.
</p><div class="section" title="ext2"><div class="titlepage"><div><div><h3 class="title"><a name="id318610"></a>ext2</h3></div></div></div><p>
ext2 is the oldest filesystem included in Slackware Linux for storing
data on hard disks. Compared to other filesystems, ext2 is simplistic.
It is faster than most others for reading and writing data, but does
not include any journaling capability. This means that after a hard
crash, the filesystem must be exhaustively checked to discover and
(hopefully) fix any errors. 
</p></div><div class="section" title="ext3"><div class="titlepage"><div><div><h3 class="title"><a name="id318624"></a>ext3</h3></div></div></div><p>
ext3 is the younger cousin of ext2. It was designed to replace ext2 in
most situations and shares much the same code-base, but adds journaling
support. In fact, ext3 and ext2 are so much alike that it is possible
to convert one to the other on the fly without lose of data. ext3
enjoys a lot of popularity for these reasons. There are many tools
available for recovering data from this filesystem in the event of
catastrophic hardware failure as well. ext3 is a good general purpose
filesystem with journaling support, but fails to perform as well as
other journaling filesystems in specific cases. One pitfall to ext3 is
that the filesystem must still go through this exhaustive check every
so often. This is done when the filesystem is mounted, usually when the
computer is booted, and causes an annoying delay.
</p></div><div class="section" title="reiserfs"><div class="titlepage"><div><div><h3 class="title"><a name="id318642"></a>reiserfs</h3></div></div></div><p>
reiserfs is one of the oldest journaling filesystems for the Linux
kernel and has been supported by Slackware for many years. It is a very
fast filesystem particularly well suited for storing, retrieving, and
writing lots of small files. Unfortunately there are few tools for
recovering data should you experience a drive failure, and reiserfs
partitions experience corruption more often than ext3. 
</p></div><div class="section" title="XFS"><div class="titlepage"><div><div><h3 class="title"><a name="id318656"></a>XFS</h3></div></div></div><p>
XFS was contributed to the Linux kernel by SGI and is one of the best
filesystems for working with large volumes and large files. XFS uses
more RAM than other filesystems, but if you need to work with large
files its performance there is well worth the penalty in memory usage.
XFS is not particularly ill-suited for desktop or laptop use, but
really shines on a server that handles medium to large size files all
day long. Like ext3, XFS is a fully journaled filesystem. 
</p></div><div class="section" title="JFS"><div class="titlepage"><div><div><h3 class="title"><a name="id318671"></a>JFS</h3></div></div></div><p>
JFS was contributed to the Linux kernel by IBM and is well known for
its responsiveness even under extreme conditions. It can span colossal
volumes making it particularly well-suited for Network Attached Storage
(NAS) devices. JFS's long history and thorough testing make it one of
the most reliable journaling filesystems available for Linux. 
</p></div><div class="section" title="iso9660"><div class="titlepage"><div><div><h3 class="title"><a name="id318685"></a>iso9660</h3></div></div></div><p>
iso9660 is a filesystem specifically designed for optical media such as
CDs and DVDs. Since optical disks are read-only media, the linux kernel
does not even include write support for this filesystem. In order to
create an iso9660 filesystem, you must use user-land tools like
<span class="application">mkisofs</span>(8) or
<span class="application">growisofs</span>(8).
</p></div><div class="section" title="vfat"><div class="titlepage"><div><div><h3 class="title"><a name="id318711"></a>vfat</h3></div></div></div><p>
Sometimes you may need to share data between Windows and Linux
computers, but can't transfer the files over a network. Instead you
require a shared hard drive partition or a USB flash drive. The humble
vfat filesystem is the best choice here since it is supported by the
largest variety of operating systems. Unfortuantely, being a Microsoft
designed filesystem, it does not store permissions in the same way as
traditional Linux filesystems. This means that special options must be
used to allow multiple users to access data on this filesystem. 
</p></div><div class="section" title="swap"><div class="titlepage"><div><div><h3 class="title"><a name="id355976"></a>swap</h3></div></div></div><p>
Unlike other filesystems which hold files and directories, swap
partitions hold virtual memory. This is very useful as it prevents the
system from crashing should all your RAM be consumed. Instead, the
kernel copies portions of the RAM into swap and frees them up for other
applications to use. Think of it as adding virtual memory to your
computer, very slow virtual memory. swap is typically a fail-safe and
shouldn't be relied upon for continual use. Add more RAM to your system
if you find yourself using lots of swap. 
</p></div></div><div class="section" title="Using mount"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id355992"></a>Using <span class="application">mount</span></h2></div></div></div><p>
Now that we've learned what (some of) the different filesystems
available in Linux are, it's time we looked at how to use them. In
order to read or write data on a filesystem, that filesystem must first
be mounted. To do this, we (naturally) use
<span class="application">mount</span>(8). The first thing we must do is
decide where we want the filesystem located. Recall that there are no
such things are drive letters denoting filesystems in Linux. Instead,
all filesystems are mounted on directories. The base filesystem on
which you install Slackware is always located at <code class="filename">/</code>
and others are always located in subdirectories of
<code class="filename">/</code>. <code class="filename">/mnt/hd</code> is a common place
to temporarily locate a partition, so we'll use that in our first
example. In order to mount a filesystem's contents, we must tell mount
what kind of filesystem we have, where to mount it, and any special
options to use. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount -t ext3 /dev/hda3 /mnt/hd -o ro</code></strong>
</pre><p>
Let's disect this. We have an ext3 filesystem located on the third
partition of the first IDE device, and we've decided to mount its
contents on the directory <code class="filename">/mnt/hd</code>. Additionally,
we have mounted it read-only so no changes can be made to these
contents. The  [-t ext3] argument tells
<span class="application">mount</span>
what type of filesystem we are using,
in this case it is ext3. This lets the kernel know which driver to use.
Often <span class="application">mount</span> can determine this for itself,
but it never hurts to explicitly declare it. Second, we tell
<span class="application">mount</span> 
where to locate the filesystem's contents. Here we've chosen
<code class="filename">/mnt/hd</code>.
Finally, we must decide what options to use if any. These are declared
with the  [-o] argument. A short-list of the most common
options follows. 
</p><div class="table"><a name="id356105"></a><p class="title"><b>Table 10.2. Common mount options</b></p><div class="table-contents"><table summary="Common mount options" border="1"><colgroup><col><col></colgroup><thead></thead><tbody><tr><td>ro</td><td>read-only</td></tr><tr><td>rw</td><td>read-write (default)</td></tr><tr><td>uid</td><td>user to own the contents of the filesystem</td></tr><tr><td>gid</td><td>group to own the contents of the filesystem</td></tr><tr><td>noexec</td><td>prevent execution of any files on the filesystem</td></tr><tr><td>defaults</td><td>sane defaults for most filesystems</td></tr></tbody></table></div></div><br class="table-break"><p>
If this is your first Linux installation, the only options you
typically need to be concerned about are [ro] and
 [rw]. The exception to this rule comes when you are dealing
with filesystems that don't handle traditional Linux permissions such
as vfat or NTFS. In those cases you'll need to use the  [uid]
or  [gid] options to allow non-root users access to these
filesystems.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount -t vfat /dev/hda4 /mnt/hd -o uid=alan</code></strong>
</pre><p>
But Alan, that's appalling! I don't want to have to tell mount what
filesystem or options to use everytime I load a CD. It should be easier
than that. Well thankfully, it is. The <code class="filename">/etc/fstab</code>
file contains all this information for filesystems that the installer
sets up for you, and you can make additions to it as well.
<code class="filename">fstab</code>(5) looks like a simple table containing the
device to mount along with its filesystem type and optional arguments.
Let's take a look. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>cat /etc/fstab</code></strong>
/dev/hda1        /                reiserfs    defaults               1   1
/dev/hda2        /home            reiserfs    defaults               1   2
/dev/hda3        swap             swap        defaults               0   0
/dev/cdrom       /mnt/cdrom       auto        noauto,owner,ro,users  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner           0   0
devpts           /dev/pts         devpts      gid=5,mode=620         0   0
proc             /proc            proc        defaults               0   0
</pre><p>
If you have an entry in <code class="filename">fstab</code> for your filesystem, you
need only tell mount the device node or the mount location. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount /dev/cdrom</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount /home</code></strong>
</pre><p>
One final use for
<span class="application">mount</span>
is to tell you what filesystems are currently mounted and with what
options. Simply run
<span class="application">mount</span>
without any arguments to display these. 
</p></div><div class="section" title="Network Filesystems"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id360747"></a>Network Filesystems</h2></div></div></div><p>
In addition to local filesystems, Slackware supports a number of network
filesystems as both client and server. This allows you to share data
between multiple computers transparently. We'll discuss the two most
common: NFS and SMB. 
</p><div class="section" title="NFS"><div class="titlepage"><div><div><h3 class="title"><a name="id360758"></a>NFS</h3></div></div></div><p>
NFS is the Network File System for Linux as well as several other common
operating systems. It has modest performance but supports the full range of
permissions for Slackware. In order to use NFS as either a client or a
server, you must run the remote procedure call daemon. This is easily
accomplished by setting the <code class="filename">/etc/rc.d/rc.rpc</code> file
executable and telling it to start. Once it has been set executable, it
will run automatically every time you boot into Slackware. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>chmod +x /etc/rc.d/rc.rpc</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>/etc/rc.d/rc.rpc start</code></strong>
</pre><p>
Mounting an NFS share is little different than mounting a local filesystem.
Rather than specifying a local device, you must tell mount the domain name
or IP address of the NFS server and the directory to mount with a colon
between them. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount -t nfs darkstar.example.com:/home /home</code></strong>
</pre><p>
Running an NFS server is a little bit different. First, you must configure
each directory to be exported in the <code class="filename">/etc/exports</code>
file. <code class="filename">exports</code>(5) contains information about what
directories will be shared, who they will be shared with, and what special
permissions to grant or deny. 
</p><pre class="screen">
# See exports(5) for a description.
# This file contains a list of all directories exported to other computers.
# It is used by rpc.nfsd and rpc.mountd.

/home/backup	192.168.1.0/24(sync,rw,no_root_squash)
</pre><p>
The first column in
<code class="filename">exports</code>
is a list of the files to be exported via NFS. The second column is a list
of what systems may access the export along with special permissions. You
can specify hosts via domain name, IP address, or netblock address (as I
have here). Special permissions are always a parenthetical list. For a
complete list, you'll need to read the man page. For now, the only special
option that matters is  [no_root_squash]. Usually the root user on
an NFS client cannot read or write an exported share. Instead, the root
user is "squashed" and forced to act as the nobody user.
 [no_root_squash] prevents this.
</p><p>
You'll also need to run the NFS daemon. Starting and stopping NFS server
support is done with the <code class="filename">/etc/rc.d/rc.nfsd</code> rc script.
Set it executable and run it just like we did for
<code class="filename">rc.rpc</code> and you are ready to go. 
</p></div><div class="section" title="SMB"><div class="titlepage"><div><div><h3 class="title"><a name="id360899"></a>SMB</h3></div></div></div><p>
SMB is the Windows network file-sharing protocol. Connecting to SMB shares
(commonly called samba shares) is fairly straight forward. Unfortuantely,
SMB isn't as strongly supported as NFS. Still, it offers higher performance
and connectivity with Windows computers. For these reasons, SMB is the most
common network file-sharing protocol deployed on local networks. Exporting
SMB shares from Slackware is done through the samba daemon and configured
in <code class="filename">smb.conf</code>(5). Unfortunately configuring samba as a
service is beyond the scope of this book. Check online for additional
documentation, and as always refer to the man page. 
</p><p>
Thankfully mounting an SMB share is easy and works almost exactly like
mounting an NFS share. You must tell mount where to find the server and
what share you wish to access in exactly the same way. Additionally, you
must specify a username and password. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount -t cifs //darkstar/home /home -o username=alan,password=secret</code></strong>
</pre><p>
You may be wondering why the filesystem type is cifs instead of smbfs. In
older versions of the Linux kernel, smbfs was used. This has been
deprecated in favor of the better performing and more secure general
purpose cifs driver. 
</p><p>
All SMB shares require the [username] and  [password]
arguments. This can create a security problem if you wish to place your
samba share in fstab. You may avoid this problem by using the
 [credentials] argument.  [credentials] points to a file
which contains the username and password information. As long as this file
is safely guarded and readable only by root, the likelyhood that your
authentication credentials will be compromised is lessened. 
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>echo "username=alan" &gt; /etc/creds-home</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>echo "password=secret" &gt;&gt; /etc/creds-home</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>mount -t cifs //darkstar/home -o credentials=/etc/creds-home</code></strong>
</pre></div></div></div><div class="chapter" title="Chapter 11. vi"><div class="titlepage"><div><div><h2 class="title"><a name="id282063"></a>Chapter 11. <span class="application">vi</span></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id352102">What is <span class="application">vi</span>?</a></span></dt><dt><span class="section"><a href="#id314220">The Different Modes of <span class="application">vi</span></a></span></dt><dt><span class="section"><a href="#id317601">Opening, Saving, and Quitting</a></span></dt><dt><span class="section"><a href="#id320876">Moving Around</a></span></dt><dt><span class="section"><a href="#id342976">Editing A Document</a></span></dt><dt><span class="section"><a href="#id343009"><span class="application">vi</span> Cheat Sheet</a></span></dt></dl></div><div class="section" title="What is vi?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id352102"></a>What is <span class="application">vi</span>?</h2></div></div></div><p>
Scattered all around your computer are thousands of text files. To a
new user, this may seem inconsequential, but almost everything in
Slackware Linux uses a plain-text file for configuration. This allows
users to make changes to the system quickly, easily, and intuitively.
In chapter 5, we looked at a few commands such as
<span class="application">cat</span> and <span class="application">less</span> that
can be used to read these files, but what if we want to make changes to
them? For that, we need a text editor, and
<span class="application">vi</span> is up to the task.
</p><p>
In short, <span class="application">vi</span> is one of the oldest and most
powerful text editors still used today. It's beloved by system
administrators, programmers, hobbiests, and others the world over. In
fact, nearly this entire book was written using
<span class="application">vi</span>; only the next chapter on
<span class="application">emacs</span> was written with that editor.
</p><p>
A little further explanation is needed to learn exactly what
<span class="application">vi</span> is today though, as Slackware Linux
technically doesn't include <span class="application">vi</span>. Rather,
Slackware includes two vi "clones", <span class="application">elvis</span>(1)
and <span class="application">vim</span>(1). These clones add many additional
features to vi such as syntax highlighting, binary editing modes, and
network support. We won't go too deeply into all these details. By
default, if you execute <span class="application">vi</span> on Slackware
Linux, you'll be using <span class="application">elvis</span>, so all
examples in this chapter will assume that is what you are using. If
you've used another Linux distribution before, you may be more familiar
with <span class="application">vim</span>. If so, you might wish to change
the symlink for <code class="filename">/usr/bin/vi</code> to point to
<code class="filename">/usr/bin/vim</code>, or add an alias to your shell's
startup scripts. <span class="application">vim</span> is generally considered
to be more feature-rich than <span class="application">elvis</span>, but
<span class="application">elvis</span> is a much smaller program and contains
more features than most users will ever need.
</p><p>
<span class="application">vi</span> is very powerful, but also somewhat
cumbersome and challening for a new user to learn. However, mastering 
<span class="application">vi</span> is an important skill for any
self-respecting system administrator to learn, as 
<span class="application">vi</span> is included on nearly every Linux
distribution, every BSD system, and every UNIX system in existance. 
It's even included in Mac OS X.
Once you've learned <span class="application">vi</span>, you'll not have to
learn another text editor to work on any of these systems. In fact,
<span class="application">vi</span> clones have even been ported to Microsoft Windows
systems, so you can use it there too.
</p></div><div class="section" title="The Different Modes of vi"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id314220"></a>The Different Modes of <span class="application">vi</span></h2></div></div></div><p>
New users are often frustrated when using <span class="application">vi</span>
for the first time. When invoked without any arguments, 
<span class="application">vi</span> will display a screen something like
this.
</p><pre class="screen">
~
~
~
~
~
~
~
~
~
~
~
                                     Command
</pre><p>
At this point, the user will being typing and expect the keys he
presses to appear in the document. Instead, something really strange
happens. The reason for this is simple. <span class="application">vi</span>
has different operation "modes". There is a command mode and an insert
mode. Command mode is the default; in this mode, each keystroke
performs a particular action such as moving the cursor around, deleting
text, yanking (copying) text, searching, etc.
</p></div><div class="section" title="Opening, Saving, and Quitting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id317601"></a>Opening, Saving, and Quitting</h2></div></div></div><p>
Ok, so you've decided that you want to learn how to use 
<span class="application">vi</span>. The first thing to do is learn how to
open and save files. Opening files is actually pretty easy. Simply type
the filename as an argument on the command-line and 
<span class="application">vi</span> will happily load it for you. For
example, <strong class="userinput"><code>vi chapter_11.xml</code></strong> will open the file
<code class="filename">chapter_11.xml</code> and load its content onto the
screen, simple enough. But what if we've finished with one document and
wish to save it? We can do that in command mode using the  [:w]
command. When in command mode, pressing the <span class="keycap"><strong>:</strong></span> key
temporarily positions the cursor on the very bottom line of the window
and allows you to enter special commands. (This is technically known as
ex-mode after the venerable <span class="application">ex</span> application
which we will not document here.) The command to save your current work
is  [:w]. Once this is done, <span class="application">vi</span> will
write your changes to the buffer back into the file. If you wish to
open another document, simply use the  [:e other_document]
command and <span class="application">vi</span> will happily open it for you.
If you've made changes to the buffer but haven't saved it yet,
 [:e] will fail and print a warning message on the bottom line.
You can bypass this with the  [:e!] command. Most ex-mode
commands in <span class="application">vi</span> can be "forced" by adding
<span class="keycap"><strong>!</strong></span> to them. This tells <span class="application">vi</span>
that you want to abandon any changes you've made to the buffer and open
the other document immediately.
</p><p>
But what if I don't like my changes and want to quit or start over?
That's easily done as well. Executing the [:e!] command
without any arguments will re-open the current document from the
beginning. Quitting <span class="application">vi</span> is as simple as
running the  [:q] command if you haven't made any changes to
the buffer, or  [:q!] if you'd like to quit and abandon those
changes.
</p></div><div class="section" title="Moving Around"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id320876"></a>Moving Around</h2></div></div></div><p>
Moving around in <span class="application">vi</span> is perhaps the hardest
thing for a new user to learn. <span class="application">vi</span> does not
traditionally use the directional arrow keys for cursor movement,
although in Slackware Linux that is an option. Rather, movement is
simply another command issued in command-mode. The reason for this is
rather simple. <span class="application">vi</span> actually predates the
inclusion of directional arrow keys on keyboards. Thus,
movement of the cursor had to be accomplished by using the few
keys available, so the right-hand "home row" keys of
<span class="keycap"><strong>h</strong></span>, <span class="keycap"><strong>j</strong></span>, <span class="keycap"><strong>k</strong></span>, and
<span class="keycap"><strong>l</strong></span> were chosen. These keys will move the cursor about
whenever <span class="application">vi</span> is in command mode. Here's a
short table to help you remember how they work.
</p><div class="table"><a name="id348996"></a><p class="title"><b>Table 11.1. vi cursor movement</b></p><div class="table-contents"><table summary="vi cursor movement" border="1"><colgroup><col><col></colgroup><thead><tr><th>Command</th><th>Result</th></tr></thead><tbody><tr><td>h</td><td>Move the cursor one character left.</td></tr><tr><td>j</td><td>Move the cursor one line down</td></tr><tr><td>k</td><td>Move the cursor one line up</td></tr><tr><td>l</td><td>Move the cursor one character right</td></tr></tbody></table></div></div><br class="table-break"><p>
Moving around is a little more powerful than that though. Like many
command keys, these movement keys accept numerical arguments. For
example, <span class="keycap"><strong>10j</strong></span> will move the cursor down 10 lines. You
can also move to the end or beginning of the current line with
<span class="keycap"><strong>$</strong></span> and <span class="keycap"><strong>^</strong></span>, respectively.
</p></div><div class="section" title="Editing A Document"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id342976"></a>Editing A Document</h2></div></div></div><p>
Now that we're able to open and save documents, as well as move around
in them, it's time to learn how to edit them. The primary means of
editing is to enter insert mode using either the <span class="keycap"><strong>i</strong></span> or
<span class="keycap"><strong>a</strong></span> command keys.  These either insert text at the
cursor's current location, or append it after the cursor's current
location. Once into insert mode, you can type any text normally and it
will be placed into your document.  You can return to command mode in
order to save your changes by pressing the <span class="keycap"><strong>ESC</strong></span> key.
</p></div><div class="section" title="vi Cheat Sheet"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id343009"></a><span class="application">vi</span> Cheat Sheet</h2></div></div></div><p>
Since <span class="application">vi</span> can be difficult to learn, I've
prepared a short cheat sheat that should help you with the basics until
you begin to feel comfortable.
</p><div class="table"><a name="id343030"></a><p class="title"><b>Table 11.2. vi Cheat Sheet</b></p><div class="table-contents"><table summary="vi Cheat Sheet" border="1"><colgroup><col><col></colgroup><thead><tr><th>Command</th><th>Result</th></tr></thead><tbody><tr><td>h</td><td>Move the cursor one character left.</td></tr><tr><td>j</td><td>Move the cursor one line down</td></tr><tr><td>k</td><td>Move the cursor one line up</td></tr><tr><td>l</td><td>Move the cursor one character right</td></tr><tr><td>10j</td><td>Move the cursor ten lines down</td></tr><tr><td>G</td><td>Move to the end of the file</td></tr><tr><td>^</td><td>Move to the beginning of the line</td></tr><tr><td>$</td><td>Move to the end of the line</td></tr><tr><td>dd</td><td>Remove a line</td></tr><tr><td>5dd</td><td>Remove 5 lines</td></tr><tr><td>r</td><td>Replace a single character</td></tr><tr><td>R</td><td>Replace multiple characters</td></tr><tr><td>x</td><td>Delete a character</td></tr><tr><td>X</td><td>Delete the previous character</td></tr><tr><td>u</td><td>Undo the last action</td></tr><tr><td>:s'old'new'g</td><td>Replace all occurances of 'old' with 'new'</td></tr><tr><td>/asdf</td><td>Locate next occurance of asdf</td></tr><tr><td>:q</td><td>Quit (without saving)</td></tr><tr><td>:w</td><td>Save the current document</td></tr><tr><td>:w file</td><td>Save the current document as 'file'</td></tr><tr><td>:x</td><td>Save and quit</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="chapter" title="Chapter 12. Emacs"><div class="titlepage"><div><div><h2 class="title"><a name="id342041"></a>Chapter 12. Emacs</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id317667">No Idea</a></span></dt></dl></div><div class="section" title="No Idea"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id317667"></a>No Idea</h2></div></div></div></div></div><div class="chapter" title="Chapter 13. Networking"><div class="titlepage"><div><div><h2 class="title"><a name="id289613"></a>Chapter 13. Networking</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id328201"><span class="application">netconfig</span></a></span></dt><dt><span class="section"><a href="#id310624">Manual Configuration</a></span></dt><dt><span class="section"><a href="#id319849">Automatic Configuration with rc.inet1.conf</a></span></dt></dl></div><div class="section" title="netconfig"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id328201"></a><span class="application">netconfig</span></h2></div></div></div><p>
Computers aren't very interesting on their own. Sure, you can install
games on them, but that just turns them into glorified entertainment
consoles. Today, computers need to be able to talk to one another; they
need to be networked. Whether you're installing a business network with
hundreds or thousands of computers or just setting up a single PC for
Internet access, Slackware is simple and easy. This chapter should
teach you how to setup typical wired networks. Common wireless setup will
be thoroughly discussed in the next section, but much of what you read
here will be applicable there as well.
</p><p>
There are many different ways to configure your computer to connect to
a network or the Internet, but they fall into two main categories:
static and dymanic. Static addresses are solid; they are set with the
understanding that they will not be changed, at least not anytime soon.
Dynamic addresses are fluid; the assumption is that the address will
change at some time in the future. Typically any sort of network server
requires a static address simply so other machines will know where to
contact it when they need services. Dynamic addresses tend to be used
for workstations, Internet clients, and any machine that doesn't
require a static address for any reason. Dynamic addresses are more
flexible, but present complications of their own.
</p><p>
There are many different kinds of network protocols that you might
encounter, but most people will only ever need to deal with Internet
Protocol (IP). For that reason, we'll focus exclusively on IP in this
book.
</p></div><div class="section" title="Manual Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id310624"></a>Manual Configuration</h2></div></div></div><p>
Ok, so you've installed Slackware, you've setup a desktop, but you
can't get it to connect to the Internet or your business's LAN (local
area network), what do you do? Fortunately, the answer to that question
is simple. Slackware includes a number of tools to configure your
network connection. The first we will look at today is the very
powerful <span class="application">ifconfig</span>(8).
<span class="application">ifconfig</span> is used to setup or modify the
configuration of a Network Interface Card (NIC or Ethernet Card), the
most common hardware for connecting to networks today.
<span class="application">ifconfig</span> is an incredibly powerful tool
capable of doing much more than setting IP addresses. For a complete
introduction, you should read its man page. For now, we're just going
to use it to display and change the network addresses of some ethernet
controllers.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ifconfig</code></strong>
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:699 errors:0 dropped:0 overruns:0 frame:0
          TX packets:699 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:39518 (38.5 KiB)  TX bytes:39518 (38.5 KiB)

wlan0     Link encap:Ethernet  HWaddr 00:1c:b3:ba:ad:4c  
          inet addr:192.168.1.198  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::21c:b3ff:feba:ad4c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1630677 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1183224 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:1627370207 (1.5 GiB)  TX bytes:163308463 (155.7 MiB)

wmaster0  Link encap:UNSPEC  HWaddr 00-1C-B3-BA-AD-4C-00-00-00-00-00-00-00-00-00-00  
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</pre><p>
As you can clearly see here, when run without any arguments,
<span class="application">ifconfig</span> will display all the information it
has on all the ethernet cards (and wireless ethernet cards) present on
your system. The above represents a typical wireless connection from my
laptop, so don't be afraid if what you see on your system doesn't
match.  If you don't see any ethX or wlanX interfaces though, the
interface may be down. To show all currently present NICs whether they are
"up" or "down", simply pass the  [-a] argument.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ifconfig -a</code></strong>
eth0      Link encap:Ethernet  HWaddr 00:19:e3:45:90:44  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:122780 errors:0 dropped:0 overruns:0 frame:0
          TX packets:124347 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:60495452 (57.6 MiB)  TX bytes:17185220 (16.3 MiB)
          Interrupt:16 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:699 errors:0 dropped:0 overruns:0 frame:0
          TX packets:699 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:39518 (38.5 KiB)  TX bytes:39518 (38.5 KiB)

wlan0     Link encap:Ethernet  HWaddr 00:1c:b3:ba:ad:4c  
          inet addr:192.168.1.198  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::21c:b3ff:feba:ad4c/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1630677 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1183224 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:1627370207 (1.5 GiB)  TX bytes:163308463 (155.7 MiB)

wmaster0  Link encap:UNSPEC  HWaddr 00-1C-B3-BA-AD-4C-00-00-00-00-00-00-00-00-00-00  
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</pre><p>Notice that the eth0 interface is now listed among the returns.
<span class="application">ifconfig</span> can also change the current
settings on a NIC. Typically, you would need to change the IP address
and subnet mask, but you can change virtually any parameters.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>ifconfig eth0</code></strong>
eth0      Link encap:Ethernet  HWaddr 00:19:e3:45:90:44  
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:122780 errors:0 dropped:0 overruns:0 frame:0
          TX packets:124347 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:60495452 (57.6 MiB)  TX bytes:17185220 (16.3 MiB)
          Interrupt:16 
</pre><p>
If you look carefully, you'll notice that the interface now has the
192.168.1.1 IP address and a 255.255.255.0 subnet mask. We've now setup
the basics for connecting to our network, but we still need to setup a
default gateway and our DNS servers. In order to do that, we'll need to
look at a few more tools.
</p><p>
Next on our stop through networking land is the equally powerful
<span class="application">route</span>(8). This tool is responsible for
modifying the Linux kernel's routing table which affects all data
transmission on a network. Routing tables can become immensely complex
or they can be straight-forward and simple. Most users will only ever
need to setup a default gateway, so we'll show you how to do that here.
If for some reason you need a more complex routing table, you would be
well advised to read the entire man page for
<span class="application">route</span> as well as consulting other sources.
For now, let's take a look at our routing table immediately after
setting up eth0.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>route</code></strong>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     *               255.255.255.0   U     0      0        0 eth0
loopback        *               255.0.0.0       U     0      0        0 lo
</pre><p>
I won't explain everything here, but the general information should be
easy to pick up if you're familiar with networking at all. The
Destination and Genmask fields specify a range of IP addresses to
match. If a Gateway is defined, information in the form of packets will
be sent to that host for forwarding. We also specify an interface in
the final field that the information should traverse. Right now, we can
only communicate with computers with addresses between 192.168.1.0 and
192.168.1.255 and ourselves through the loopback interface, a type of
virtual NIC that is used for routing information from this computer to
itself.  In order to reach the rest of the world, we'll need to
setup a default gateway.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>route add default gw 192.168.1.254</code></strong>
<code class="prompt">darkstar:~# </code><strong class="userinput"><code>route</code></strong>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     *               255.255.255.0   U     0      0        0 eth0
loopback        *               255.0.0.0       U     0      0        0 lo
default         192.168.1.254   0.0.0.0         UG    0      0        0 eth0
</pre><p>
You should immediately notice the addition of a default route. This
specifies what router should be used to reach any addresses that aren't
specified elsewhere in our routing table. Now, when we try to connect
to say, 64.57.102.34, the information will be sent to 192.168.1.254
which is responsible for delivering the data for us. Unfortunately,
we're still not quite through. We need some way of converting domain
names like slackware.com into IP addresses that the computer can use.
For that, we need to make use of a DNS server.
</p><p>
Fortunately, setting up your computer to use an external (or even an
internal) DNS server is very easy. You'll need to use your favorite
text editor and open the <code class="filename">/etc/resolv.conf</code> file.
Don't ask me what happened to the <span class="keycap"><strong>e</strong></span>. On my computer,
<code class="filename">resolv.conf</code> looks like this.
</p><pre class="screen">
# /etc/resolv.conf
search lizella.net
nameserver 192.168.1.254
</pre><p>
Most users won't need the "search" line. This is used to map hostnames
to domain names. Basically, if I attempt to connect to "barnowl", the
computer knows to look for "barnowl.lizella.net" thanks to this search
line. We're mainly interested in the "nameserver" line. This tells
Slackware what domain name servers (DNS) to connect to. Generally
speaking, these should always be specified by IP address. If you know
what DNS servers you should use, you can just add them one at a time to
individual nameserver lines. In fact, I don't know of any practical
limit to the number of nameservers that can be specified in
<code class="filename">resolv.conf</code>, so add as many as you like. Once this
is done, you should be able to communicate with other hosts via their
fully qualified domain name.
</p><p>
But Alan! That's a lot of hard work! I don't want to do this time and
again for dozens or even hundreds of machines. You're absolutely right,
and that's why smarter people than you and me created DHCP.  DHCP
stands for Dynamic Host Control Protocol and is a method for
automatically configuring computers with unique IP addresses, netmasks,
gateways, and DNS servers. Most of the time, you'll want to use DHCP.
The majority of wireless routers, DSL or cable modems, even firewalls
all have DHCP servers to can make your life much easier. Slackware
includes two main tools for connecting to an exising DHCP server and
can even act as a DHCP server for other computers. For now though,
we're just going to look at DHCP clients.
</p><p>
First on our list is <span class="application">dhcpcd</span>(8), part of the
ISC DHCP utilities. Assuming your computer is physically connected to
your network, and that you have an operating DHCP server on that
network, you can configure your NIC in one shot.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>dhcpcd eth0</code></strong>
</pre><p>
If everything went according to plan, your NIC should be properly
configured, and you should be able to communicate with other computers
on your network, and with the Internet at large. If for some reason,
<span class="application">dhcpcd</span> fails, you may want to try
<span class="application">dhclient</span>(8).
<span class="application">dhclient</span> is an alternative to
<span class="application">dhcpcd</span> and works in basically the same way.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>dhclient eth0</code></strong>
Listening on LPF/eth0/00:1c:b3:ba:ad:4c
Sending on   LPF/eth0/00:1c:b3:ba:ad:4c
Sending on   Socket/fallback
DHCPREQUEST on eth0 to 255.255.255.255 port 67
DHCPACK from 192.168.1.254
bound to 192.168.1.198 -- renewal in 8547 seconds.
</pre><p>
So why does Slackware include two DHCP clients? Sometimes a particular
DHCP server may be broken and not respond well to either 
<span class="application">dhcpcd</span> or
<span class="application">dhclient</span>. In those cases, you can fall back
to the other DHCP client in hopes of getting a valid response from the
server. Traditionally, Slackware uses
<span class="application">dhcpcd</span>, and this works in the vast majority
of cases, but it may become necessary at some point for you to use
<span class="application">dhclient</span> instead. Both are excellent DHCP
clients, so use whichever you prefer.
</p></div><div class="section" title="Automatic Configuration with rc.inet1.conf"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id319849"></a>Automatic Configuration with rc.inet1.conf</h2></div></div></div><p>
Manually configuring interfaces is an important skill to have, but it
can become tedious.  No one wants to manually setup their Internet
connection every time the system boots.  More importantly, you may not
always have physical access to the machine when it boots.  Slackware
makes it easy to automatically configure ethernet (and wireless) cards
at system startup with <code class="filename">/etc/rc.d/rc.inet1.conf</code>.
For now, we're going to focus on traditional wired ethernet networking;
the next chapter will discuss various wireless options.
</p><p>
<code class="filename">rc.inet1.conf</code> is an incredibly powerful
configuration file, capable of configuring most of your network cards
automatically when Slackware is started. The file is filled with useful
comments, but there is also a man page that more thoroughly discusses
its use.  To begin, we're going to look at some of the options used on
one of my personal machines.
</p><pre class="screen">
# Config information for eth0:
IPADDR[0]="192.168.1.250"
NETMASK[0]="255.255.255.0"
USE_DHCP[0]=""
DHCP_HOSTNAME[0]=""
# Some lines ommitted.
GATEWAY="192.168.1.254"
</pre><p>
This represents most of the information necessary to configure a static
IP address on a single ethernet controller.
<span class="application">netconfig</span> will usually fill in these values 
for a single ethernet device for you.  If you have multiple network
cards in your machine and need all of them activated automatically at
boot time, then you'll need to edit or add additional entries into this
file in the same manner as above.  First, let me go over some of the
basics.
</p><p>
As you may have already guessed, IPADDR[n] is the Internet Protocol
Address for the "n" network interface card.  Typically, "n" corrosponds
to eth0, eth1, and so on, but this isn't always the case.  You can
specify these values to pertain to a different network controller with
the INFAME[n] variable, but we will reserve that for the next chapter
on wireless networking, as it more commonly pertains to wireless
network controllers.  Likewise, NETMASK[n] is the subnet mask to use
for the network controller.  If these lines are left empty, then static
IP addresses will not be automatically assigned to this network
controller.  The USE_DHCP[n] variable tells Slackware to (naturally)
use DHCP to configure the interface.  DHCP_HOSTNAME[n] is rarely used,
but some DHCP servers may require it.  In that case, it must be set to
a valid hostname. Finally, we come to the GATEWAY variable.  It is
actually set lower in the file than it appears in my example, and it
controls the default gateway to use. You may be wondering why there is
no GATEWAY[n] variable. The answer to that lies in how Internet
Protocol works. I won't go into an indepth discussion on that subject,
but suffice it to say that there is only ever one default route that a
computer can use no matter how many interfaces are attached to it.
</p><p>
If you need to use static IP addressing, you will have to obtain a
unique static IP address and the subnet mask for the interface, as well
as the default gateway address, and enter those here. There is no place
to enter DNS information in <code class="filename">rc.inet1.conf</code>, so DNS
servers will have to be manually placed into
<code class="filename">resolv.conf</code> as we discussed above. Of course, if
you use <span class="application">netconfig</span>, this will be handled for
you by that program.  Now let's take a look at another interface on my
computer.
</p><pre class="screen">
# Config information for eth1:
IPADDR[1]=""
NETMASK[1]=""
USE_DHCP[1]="yes"
DHCP_HOSTNAME[1]=""
</pre><p>
Here I am telling Slackware to configure eth1 using DHCP. I do not need
to set the IPADDR[1] or NETMASK[1] variables when using DHCP (in fact,
if they are set, they will be ignored). Slackware will happily contact
a DHCP server as soon as the machine begins to boot.
</p></div></div><div class="chapter" title="Chapter 14. Wireless Networking"><div class="titlepage"><div><div><h2 class="title"><a name="id329344"></a>Chapter 14. Wireless Networking</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id326142"><span class="application">iwconfig</span></a></span></dt><dt><span class="section"><a href="#id359178">Wired Equivilant Protection (or Lack Thereof)</a></span></dt><dt><span class="section"><a href="#id334833">WPA</a></span></dt><dt><span class="section"><a href="#id334290">rc.inet1.conf revisited</a></span></dt></dl></div><div class="section" title="iwconfig"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id326142"></a><span class="application">iwconfig</span></h2></div></div></div><p>
Wireless networking is somewhat more complicated than traditional wired
networking, and requires additional tools for setup. Slackware includes
a diverse collection of wireless networking tools to allow you to
configure your wireless network interface card (WNIC) at the most basic
level. We won't cover everything here, but should give you a solid
foundation to get up and running quickly.  The first tool we are going
to look at is <span class="application">iwconfig</span>(8). When run without
any argument, <span class="application">iwconfig</span> displays the current
wireless information on any and all NICs on your computer.
</p><pre class="screen"><code class="prompt">darkstar:~# </code><strong class="userinput"><code>iwconfig</code></strong>
lo        no wireless extensions.

eth0      no wireless extensions.

wmaster0  no wireless extensions.

wlan0     IEEE 802.11abgn  ESSID:"nest"  
          Mode:Managed  Frequency:2.432 GHz  Access Point:
00:13:10:EA:4E:BD   
          Bit Rate=54 Mb/s   Tx-Power=17 dBm   
          Retry min limit:7   RTS thr:off   Fragment thr=2352 B   
          Encryption key:off
          Power Management:off
          Link Quality=100/100  Signal level:-42 dBm  
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0

tun0      no wireless extensions.
</pre><p>
Unlike wired networks, wireless networks are "fuzzy". Their borders are
hard to define, and multiple networks may overlap one another. In order
to avoid confusion, each wireless network has (hopefully) unique
identifiers. The two most basic identifiers are the Extended Service
Set Identifier (ESSID) and the channel or frequency for radio
transmission. The ESSID is simply a name that identifies the wireless
network in question; you may have heard it referred to as the network
name or something similar. Typical wireless networks operate on 11
different frequencies. In order to connect to even the most basic
wireless network, you will have to setup these two pieces of
information, and possibly others, before setting up things like the
WNIC's IP address.
</p></div><div class="section" title="Wired Equivilant Protection (or Lack Thereof)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id359178"></a>Wired Equivilant Protection (or Lack Thereof)</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="WPA"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id334833"></a>WPA</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="rc.inet1.conf revisited"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id334290"></a>rc.inet1.conf revisited</h2></div></div></div></div></div><div class="chapter" title="Chapter 15. Basic Networking Commands"><div class="titlepage"><div><div><h2 class="title"><a name="id284408"></a>Chapter 15. Basic Networking Commands</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id348624">Network Diagnostic Tools</a></span></dt><dt><span class="section"><a href="#id333340">Web Browsers</a></span></dt><dt><span class="section"><a href="#id351638">FTP Clients</a></span></dt><dt><span class="section"><a href="#id317884">NNTP Clients</a></span></dt><dt><span class="section"><a href="#id341101">Remote Access</a></span></dt></dl></div><div class="section" title="Network Diagnostic Tools"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id348624"></a>Network Diagnostic Tools</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Web Browsers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id333340"></a>Web Browsers</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="FTP Clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id351638"></a>FTP Clients</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="NNTP Clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id317884"></a>NNTP Clients</h2></div></div></div></div><div class="section" title="Remote Access"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id341101"></a>Remote Access</h2></div></div></div></div></div><div class="chapter" title="Chapter 16. Package Management"><div class="titlepage"><div><div><h2 class="title"><a name="id320396"></a>Chapter 16. Package Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id358328"><span class="application">pkgtool</span></a></span></dt><dt><span class="section"><a href="#id352958">Installing, Removing, and Upgrading Packages</a></span></dt><dt><span class="section"><a href="#id341343"><span class="application">pkgtool</span></a></span></dt></dl></div><div class="section" title="pkgtool"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id358328"></a><span class="application">pkgtool</span></h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Installing, Removing, and Upgrading Packages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id352958"></a>Installing, Removing, and Upgrading Packages</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="pkgtool"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id341343"></a><span class="application">pkgtool</span></h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div></div><div class="chapter" title="Chapter 17. Keeping Track of Updates"><div class="titlepage"><div><div><h2 class="title"><a name="id292742"></a>Chapter 17. Keeping Track of Updates</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id314047">The -stable Branch</a></span></dt><dt><span class="section"><a href="#id324804">Upgrading Slackware Versions</a></span></dt></dl></div><div class="section" title="The -stable Branch"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id314047"></a>The -stable Branch</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Upgrading Slackware Versions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id324804"></a>Upgrading Slackware Versions</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div></div><div class="chapter" title="Chapter 18. The Linux Kernel"><div class="titlepage"><div><div><h2 class="title"><a name="id328461"></a>Chapter 18. The Linux Kernel</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id322300">What Does the Kernel Do?</a></span></dt><dt><span class="section"><a href="#id325022">Working with Modules</a></span></dt><dt><span class="section"><a href="#id353213">Compiling A Kernel and Why to do So</a></span></dt></dl></div><div class="section" title="What Does the Kernel Do?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id322300"></a>What Does the Kernel Do?</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Working with Modules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id325022"></a>Working with Modules</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div><div class="section" title="Compiling A Kernel and Why to do So"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id353213"></a>Compiling A Kernel and Why to do So</h2></div></div></div><p>
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
voluptate velit esse cillum dolore eu fugiat nulla pariatur.
</p></div></div></div></body></html>
